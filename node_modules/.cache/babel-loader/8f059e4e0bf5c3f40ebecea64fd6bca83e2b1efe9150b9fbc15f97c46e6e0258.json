{"ast":null,"code":"import $773d5888b972f1cf$exports from \"./ar-AE.mjs\";\nimport $d11f19852b941573$exports from \"./bg-BG.mjs\";\nimport $b983974c2ee1efb3$exports from \"./cs-CZ.mjs\";\nimport $5809cc9d4e92de73$exports from \"./da-DK.mjs\";\nimport $c68c2e4fc74398d1$exports from \"./de-DE.mjs\";\nimport $0898b4c153db2b77$exports from \"./el-GR.mjs\";\nimport $6d74810286a15183$exports from \"./en-US.mjs\";\nimport $309d73dc65f78055$exports from \"./es-ES.mjs\";\nimport $44ad94f7205cf593$exports from \"./et-EE.mjs\";\nimport $7c28f5687f0779a9$exports from \"./fi-FI.mjs\";\nimport $e6d75df4b68bd73a$exports from \"./fr-FR.mjs\";\nimport $87505c9dab186d0f$exports from \"./he-IL.mjs\";\nimport $553439c3ffb3e492$exports from \"./hr-HR.mjs\";\nimport $74cf411061b983a2$exports from \"./hu-HU.mjs\";\nimport $e933f298574dc435$exports from \"./it-IT.mjs\";\nimport $ac91fc9fe02f71f6$exports from \"./ja-JP.mjs\";\nimport $52b96f86422025af$exports from \"./ko-KR.mjs\";\nimport $c0d724c3e51dafa6$exports from \"./lt-LT.mjs\";\nimport $c92899672a3fe72e$exports from \"./lv-LV.mjs\";\nimport $9f576b39d8e7a9d6$exports from \"./nb-NO.mjs\";\nimport $9d025808aeec81a7$exports from \"./nl-NL.mjs\";\nimport $fce709921e2c0fa6$exports from \"./pl-PL.mjs\";\nimport $2599cf0c4ab37f59$exports from \"./pt-BR.mjs\";\nimport $3c220ae7ef8a35fd$exports from \"./pt-PT.mjs\";\nimport $93562b5094072f54$exports from \"./ro-RO.mjs\";\nimport $cd9e2abd0d06c7b4$exports from \"./ru-RU.mjs\";\nimport $45375701f409adf1$exports from \"./sk-SK.mjs\";\nimport $27fab53a576de9dd$exports from \"./sl-SI.mjs\";\nimport $4438748d9952e7c7$exports from \"./sr-SP.mjs\";\nimport $0936d7347ef4da4c$exports from \"./sv-SE.mjs\";\nimport $29700c92185d38f8$exports from \"./tr-TR.mjs\";\nimport $662ccaf2be4c25b3$exports from \"./uk-UA.mjs\";\nimport $d80a27deda7cdb3c$exports from \"./zh-CN.mjs\";\nimport $2b2734393847c884$exports from \"./zh-TW.mjs\";\nimport $k7QOs$react, { useState as $k7QOs$useState, useRef as $k7QOs$useRef, useEffect as $k7QOs$useEffect, useCallback as $k7QOs$useCallback, useContext as $k7QOs$useContext, useMemo as $k7QOs$useMemo } from \"react\";\nimport { useLayoutEffect as $k7QOs$useLayoutEffect, useResizeObserver as $k7QOs$useResizeObserver, isWebKit as $k7QOs$isWebKit, clamp as $k7QOs$clamp, useId as $k7QOs$useId, isIOS as $k7QOs$isIOS, chain as $k7QOs$chain, getScrollParent as $k7QOs$getScrollParent, useLabels as $k7QOs$useLabels, mergeProps as $k7QOs$mergeProps } from \"@react-aria/utils\";\nimport { useLocale as $k7QOs$useLocale, useLocalizedStringFormatter as $k7QOs$useLocalizedStringFormatter } from \"@react-aria/i18n\";\nimport { isElementInChildOfActiveScope as $k7QOs$isElementInChildOfActiveScope, FocusScope as $k7QOs$FocusScope } from \"@react-aria/focus\";\nimport { useInteractOutside as $k7QOs$useInteractOutside, useFocusWithin as $k7QOs$useFocusWithin, ClearPressResponder as $k7QOs$ClearPressResponder } from \"@react-aria/interactions\";\nimport $k7QOs$reactdom from \"react-dom\";\nimport { useIsSSR as $k7QOs$useIsSSR } from \"@react-aria/ssr\";\nimport { VisuallyHidden as $k7QOs$VisuallyHidden } from \"@react-aria/visually-hidden\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */ /*\n       * Copyright 2020 Adobe. All rights reserved.\n       * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n       * you may not use this file except in compliance with the License. You may obtain a copy\n       * of the License at http://www.apache.org/licenses/LICENSE-2.0\n       *\n       * Unless required by applicable law or agreed to in writing, software distributed under\n       * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n       * OF ANY KIND, either express or implied. See the License for the specific language\n       * governing permissions and limitations under the License.\n       */\nconst $edcf132a9284368a$var$AXIS = {\n  top: \"top\",\n  bottom: \"top\",\n  left: \"left\",\n  right: \"left\"\n};\nconst $edcf132a9284368a$var$FLIPPED_DIRECTION = {\n  top: \"bottom\",\n  bottom: \"top\",\n  left: \"right\",\n  right: \"left\"\n};\nconst $edcf132a9284368a$var$CROSS_AXIS = {\n  top: \"left\",\n  left: \"top\"\n};\nconst $edcf132a9284368a$var$AXIS_SIZE = {\n  top: \"height\",\n  left: \"width\"\n};\nconst $edcf132a9284368a$var$TOTAL_SIZE = {\n  width: \"totalWidth\",\n  height: \"totalHeight\"\n};\nconst $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE = {};\n// @ts-ignore\nlet $edcf132a9284368a$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $edcf132a9284368a$var$getContainerDimensions(containerNode) {\n  let width = 0,\n    height = 0,\n    totalWidth = 0,\n    totalHeight = 0,\n    top = 0,\n    left = 0;\n  let scroll = {};\n  let isPinchZoomedIn = ($edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.scale) > 1;\n  if (containerNode.tagName === \"BODY\") {\n    let documentElement = document.documentElement;\n    totalWidth = documentElement.clientWidth;\n    totalHeight = documentElement.clientHeight;\n    var _visualViewport_width;\n    width = (_visualViewport_width = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : totalWidth;\n    var _visualViewport_height;\n    height = (_visualViewport_height = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : totalHeight;\n    scroll.top = documentElement.scrollTop || containerNode.scrollTop;\n    scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;\n    // The goal of the below is to get a top/left value that represents the top/left of the visual viewport with\n    // respect to the layout viewport origin. This combined with the scrollTop/scrollLeft will allow us to calculate\n    // coordinates/values with respect to the visual viewport or with respect to the layout viewport.\n    if ($edcf132a9284368a$var$visualViewport) {\n      top = $edcf132a9284368a$var$visualViewport.offsetTop;\n      left = $edcf132a9284368a$var$visualViewport.offsetLeft;\n    }\n  } else {\n    ({\n      width: width,\n      height: height,\n      top: top,\n      left: left\n    } = $edcf132a9284368a$var$getOffset(containerNode));\n    scroll.top = containerNode.scrollTop;\n    scroll.left = containerNode.scrollLeft;\n    totalWidth = width;\n    totalHeight = height;\n  }\n  if ((0, $k7QOs$isWebKit)() && (containerNode.tagName === \"BODY\" || containerNode.tagName === \"HTML\") && isPinchZoomedIn) {\n    // Safari will report a non-zero scrollTop/Left for the non-scrolling body/HTML element when pinch zoomed in unlike other browsers.\n    // Set to zero for parity calculations so we get consistent positioning of overlays across all browsers.\n    // Also switch to visualViewport.pageTop/pageLeft so that we still accomodate for scroll positioning for body/HTML elements that are actually scrollable\n    // before pinch zoom happens\n    scroll.top = 0;\n    scroll.left = 0;\n    top = $edcf132a9284368a$var$visualViewport.pageTop;\n    left = $edcf132a9284368a$var$visualViewport.pageLeft;\n  }\n  return {\n    width: width,\n    height: height,\n    totalWidth: totalWidth,\n    totalHeight: totalHeight,\n    scroll: scroll,\n    top: top,\n    left: left\n  };\n}\nfunction $edcf132a9284368a$var$getScroll(node) {\n  return {\n    top: node.scrollTop,\n    left: node.scrollLeft,\n    width: node.scrollWidth,\n    height: node.scrollHeight\n  };\n}\n// Determines the amount of space required when moving the overlay to ensure it remains in the boundary\nfunction $edcf132a9284368a$var$getDelta(axis, offset, size,\n// The dimensions of the boundary element that the popover is\n// positioned within (most of the time this is the <body>).\nboundaryDimensions,\n// The dimensions of the containing block element that the popover is\n// positioned relative to (e.g. parent with position: relative).\n// Usually this is the same as the boundary element, but if the popover\n// is portaled somewhere other than the body and has an ancestor with\n// position: relative/absolute, it will be different.\ncontainerDimensions, padding, containerOffsetWithBoundary) {\n  let containerScroll = containerDimensions.scroll[axis];\n  // The height/width of the boundary. Matches the axis along which we are adjusting the overlay position\n  let boundarySize = boundaryDimensions[$edcf132a9284368a$var$AXIS_SIZE[axis]];\n  // Calculate the edges of the boundary (accomodating for the boundary padding) and the edges of the overlay.\n  // Note that these values are with respect to the visual viewport (aka 0,0 is the top left of the viewport)\n  let boundaryStartEdge = boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] + padding;\n  let boundaryEndEdge = boundarySize + boundaryDimensions.scroll[$edcf132a9284368a$var$AXIS[axis]] - padding;\n  let startEdgeOffset = offset - containerScroll + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];\n  let endEdgeOffset = offset - containerScroll + size + containerOffsetWithBoundary[axis] - boundaryDimensions[$edcf132a9284368a$var$AXIS[axis]];\n  // If any of the overlay edges falls outside of the boundary, shift the overlay the required amount to align one of the overlay's\n  // edges with the closest boundary edge.\n  if (startEdgeOffset < boundaryStartEdge) return boundaryStartEdge - startEdgeOffset;else if (endEdgeOffset > boundaryEndEdge) return Math.max(boundaryEndEdge - endEdgeOffset, boundaryStartEdge - startEdgeOffset);else return 0;\n}\nfunction $edcf132a9284368a$var$getMargins(node) {\n  let style = window.getComputedStyle(node);\n  return {\n    top: parseInt(style.marginTop, 10) || 0,\n    bottom: parseInt(style.marginBottom, 10) || 0,\n    left: parseInt(style.marginLeft, 10) || 0,\n    right: parseInt(style.marginRight, 10) || 0\n  };\n}\nfunction $edcf132a9284368a$var$parsePlacement(input) {\n  if ($edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input]) return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n  let [placement, crossPlacement] = input.split(\" \");\n  let axis = $edcf132a9284368a$var$AXIS[placement] || \"right\";\n  let crossAxis = $edcf132a9284368a$var$CROSS_AXIS[axis];\n  if (!$edcf132a9284368a$var$AXIS[crossPlacement]) crossPlacement = \"center\";\n  let size = $edcf132a9284368a$var$AXIS_SIZE[axis];\n  let crossSize = $edcf132a9284368a$var$AXIS_SIZE[crossAxis];\n  $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input] = {\n    placement: placement,\n    crossPlacement: crossPlacement,\n    axis: axis,\n    crossAxis: crossAxis,\n    size: size,\n    crossSize: crossSize\n  };\n  return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n}\nfunction $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset) {\n  let {\n    placement: placement,\n    crossPlacement: crossPlacement,\n    axis: axis,\n    crossAxis: crossAxis,\n    size: size,\n    crossSize: crossSize\n  } = placementInfo;\n  let position = {};\n  // button position\n  position[crossAxis] = childOffset[crossAxis];\n  if (crossPlacement === \"center\")\n    //  + (button size / 2) - (overlay size / 2)\n    // at this point the overlay center should match the button center\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;else if (crossPlacement !== crossAxis)\n    //  + (button size) - (overlay size)\n    // at this point the overlay bottom should match the button bottom\n    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];\n  /* else {\n  the overlay top should match the button top\n  } */\n  position[crossAxis] += crossOffset;\n  // overlay top overlapping arrow with button bottom\n  const minPosition = childOffset[crossAxis] - overlaySize[crossSize] + arrowSize + arrowBoundaryOffset;\n  // overlay bottom overlapping arrow with button top\n  const maxPosition = childOffset[crossAxis] + childOffset[crossSize] - arrowSize - arrowBoundaryOffset;\n  position[crossAxis] = (0, $k7QOs$clamp)(position[crossAxis], minPosition, maxPosition);\n  // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.\n  if (placement === axis) {\n    // If the container is positioned (non-static), then we use the container's actual\n    // height, as `bottom` will be relative to this height.  But if the container is static,\n    // then it can only be the `document.body`, and `bottom` will be relative to _its_\n    // container, which should be as large as boundaryDimensions.\n    const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE[size]];\n    position[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);\n  } else position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n  return position;\n}\nfunction $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlayHeight, heightGrowthDirection) {\n  const containerHeight = isContainerPositioned ? containerOffsetWithBoundary.height : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE.height];\n  // For cases where position is set via \"bottom\" instead of \"top\", we need to calculate the true overlay top with respect to the boundary. Reverse calculate this with the same method\n  // used in computePosition.\n  let overlayTop = position.top != null ? containerOffsetWithBoundary.top + position.top : containerOffsetWithBoundary.top + (containerHeight - position.bottom - overlayHeight);\n  let maxHeight = heightGrowthDirection !== \"top\" ?\n  // We want the distance between the top of the overlay to the bottom of the boundary\n  Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top // this is the bottom of the boundary\n  - overlayTop // this is the top of the overlay\n  - (margins.top + margins.bottom + padding // save additional space for margin and padding\n  )) : Math.max(0, overlayTop + overlayHeight // this is the bottom of the overlay\n  - (boundaryDimensions.top + boundaryDimensions.scroll.top // this is the top of the boundary\n  ) - (margins.top + margins.bottom + padding // save additional space for margin and padding\n  ));\n\n  return Math.min(boundaryDimensions.height - padding * 2, maxHeight);\n}\nfunction $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {\n  let {\n    placement: placement,\n    axis: axis,\n    size: size\n  } = placementInfo;\n  if (placement === axis) return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);\n  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);\n}\nfunction $edcf132a9284368a$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight, arrowSize, arrowBoundaryOffset) {\n  let placementInfo = $edcf132a9284368a$var$parsePlacement(placementInput);\n  let {\n    size: size,\n    crossAxis: crossAxis,\n    crossSize: crossSize,\n    placement: placement,\n    crossPlacement: crossPlacement\n  } = placementInfo;\n  let position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n  let normalizedOffset = offset;\n  let space = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);\n  // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip\n  if (flip && scrollSize[size] > space) {\n    let flippedPlacementInfo = $edcf132a9284368a$var$parsePlacement(`${$edcf132a9284368a$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);\n    let flippedPosition = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n    let flippedSpace = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);\n    // If the available space for the flipped position is greater than the original available space, flip.\n    if (flippedSpace > space) {\n      placementInfo = flippedPlacementInfo;\n      position = flippedPosition;\n      normalizedOffset = offset;\n    }\n  }\n  // Determine the direction the height of the overlay can grow so that we can choose how to calculate the max height\n  let heightGrowthDirection = \"bottom\";\n  if (placementInfo.axis === \"top\") {\n    if (placementInfo.placement === \"top\") heightGrowthDirection = \"top\";else if (placementInfo.placement === \"bottom\") heightGrowthDirection = \"bottom\";\n  } else if (placementInfo.crossAxis === \"top\") {\n    if (placementInfo.crossPlacement === \"top\") heightGrowthDirection = \"bottom\";else if (placementInfo.crossPlacement === \"bottom\") heightGrowthDirection = \"top\";\n  }\n  let delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);\n  position[crossAxis] += delta;\n  let maxHeight = $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, isContainerPositioned, margins, padding, overlaySize.height, heightGrowthDirection);\n  if (userSetMaxHeight && userSetMaxHeight < maxHeight) maxHeight = userSetMaxHeight;\n  overlaySize.height = Math.min(overlaySize.height, maxHeight);\n  position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n  delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);\n  position[crossAxis] += delta;\n  let arrowPosition = {};\n  // All values are transformed so that 0 is at the top/left of the overlay depending on the orientation\n  // Prefer the arrow being in the center of the trigger/overlay anchor element\n  let preferredArrowPosition = childOffset[crossAxis] + .5 * childOffset[crossSize] - overlaySize[crossAxis];\n  // Min/Max position limits for the arrow with respect to the overlay\n  const arrowMinPosition = arrowSize / 2 + arrowBoundaryOffset;\n  const arrowMaxPosition = overlaySize[crossSize] - arrowSize / 2 - arrowBoundaryOffset;\n  // Min/Max position limits for the arrow with respect to the trigger/overlay anchor element\n  const arrowOverlappingChildMinEdge = childOffset[crossAxis] - overlaySize[crossAxis] + arrowSize / 2;\n  const arrowOverlappingChildMaxEdge = childOffset[crossAxis] + childOffset[crossSize] - overlaySize[crossAxis] - arrowSize / 2;\n  // Clamp the arrow positioning so that it always is within the bounds of the anchor and the overlay\n  const arrowPositionOverlappingChild = (0, $k7QOs$clamp)(preferredArrowPosition, arrowOverlappingChildMinEdge, arrowOverlappingChildMaxEdge);\n  arrowPosition[crossAxis] = (0, $k7QOs$clamp)(arrowPositionOverlappingChild, arrowMinPosition, arrowMaxPosition);\n  return {\n    position: position,\n    maxHeight: maxHeight,\n    arrowOffsetLeft: arrowPosition.left,\n    arrowOffsetTop: arrowPosition.top,\n    placement: placementInfo.placement\n  };\n}\nfunction $edcf132a9284368a$export$b3ceb0cbf1056d98(opts) {\n  let {\n    placement: placement,\n    targetNode: targetNode,\n    overlayNode: overlayNode,\n    scrollNode: scrollNode,\n    padding: padding,\n    shouldFlip: shouldFlip,\n    boundaryElement: boundaryElement,\n    offset: offset,\n    crossOffset: crossOffset,\n    maxHeight: maxHeight,\n    arrowSize = 0,\n    arrowBoundaryOffset = 0\n  } = opts;\n  let container = overlayNode instanceof HTMLElement ? $edcf132a9284368a$var$getContainingBlock(overlayNode) : document.documentElement;\n  let isViewportContainer = container === document.documentElement;\n  const containerPositionStyle = window.getComputedStyle(container).position;\n  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== \"static\";\n  let childOffset = isViewportContainer ? $edcf132a9284368a$var$getOffset(targetNode) : $edcf132a9284368a$var$getPosition(targetNode, container);\n  if (!isViewportContainer) {\n    let {\n      marginTop: marginTop,\n      marginLeft: marginLeft\n    } = window.getComputedStyle(targetNode);\n    childOffset.top += parseInt(marginTop, 10) || 0;\n    childOffset.left += parseInt(marginLeft, 10) || 0;\n  }\n  let overlaySize = $edcf132a9284368a$var$getOffset(overlayNode);\n  let margins = $edcf132a9284368a$var$getMargins(overlayNode);\n  overlaySize.width += margins.left + margins.right;\n  overlaySize.height += margins.top + margins.bottom;\n  let scrollSize = $edcf132a9284368a$var$getScroll(scrollNode);\n  let boundaryDimensions = $edcf132a9284368a$var$getContainerDimensions(boundaryElement);\n  let containerDimensions = $edcf132a9284368a$var$getContainerDimensions(container);\n  // If the container is the HTML element wrapping the body element, the retrieved scrollTop/scrollLeft will be equal to the\n  // body element's scroll. Set the container's scroll values to 0 since the overlay's edge position value in getDelta don't then need to be further offset\n  // by the container scroll since they are essentially the same containing element and thus in the same coordinate system\n  let containerOffsetWithBoundary = boundaryElement.tagName === \"BODY\" ? $edcf132a9284368a$var$getOffset(container) : $edcf132a9284368a$var$getPosition(container, boundaryElement);\n  if (container.tagName === \"HTML\" && boundaryElement.tagName === \"BODY\") {\n    containerDimensions.scroll.top = 0;\n    containerDimensions.scroll.left = 0;\n  }\n  return $edcf132a9284368a$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight, arrowSize, arrowBoundaryOffset);\n}\nfunction $edcf132a9284368a$var$getOffset(node) {\n  let {\n    top: top,\n    left: left,\n    width: width,\n    height: height\n  } = node.getBoundingClientRect();\n  let {\n    scrollTop: scrollTop,\n    scrollLeft: scrollLeft,\n    clientTop: clientTop,\n    clientLeft: clientLeft\n  } = document.documentElement;\n  return {\n    top: top + scrollTop - clientTop,\n    left: left + scrollLeft - clientLeft,\n    width: width,\n    height: height\n  };\n}\nfunction $edcf132a9284368a$var$getPosition(node, parent) {\n  let style = window.getComputedStyle(node);\n  let offset;\n  if (style.position === \"fixed\") {\n    let {\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    } = node.getBoundingClientRect();\n    offset = {\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n  } else {\n    offset = $edcf132a9284368a$var$getOffset(node);\n    let parentOffset = $edcf132a9284368a$var$getOffset(parent);\n    let parentStyle = window.getComputedStyle(parent);\n    parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;\n    parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;\n    offset.top -= parentOffset.top;\n    offset.left -= parentOffset.left;\n  }\n  offset.top -= parseInt(style.marginTop, 10) || 0;\n  offset.left -= parseInt(style.marginLeft, 10) || 0;\n  return offset;\n}\n// Returns the containing block of an element, which is the element that\n// this element will be positioned relative to.\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\nfunction $edcf132a9284368a$var$getContainingBlock(node) {\n  // The offsetParent of an element in most cases equals the containing block.\n  // https://w3c.github.io/csswg-drafts/cssom-view/#dom-htmlelement-offsetparent\n  let offsetParent = node.offsetParent;\n  // The offsetParent algorithm terminates at the document body,\n  // even if the body is not a containing block. Double check that\n  // and use the documentElement if so.\n  if (offsetParent && offsetParent === document.body && window.getComputedStyle(offsetParent).position === \"static\" && !$edcf132a9284368a$var$isContainingBlock(offsetParent)) offsetParent = document.documentElement;\n  // TODO(later): handle table elements?\n  // The offsetParent can be null if the element has position: fixed, or a few other cases.\n  // We have to walk up the tree manually in this case because fixed positioned elements\n  // are still positioned relative to their containing block, which is not always the viewport.\n  if (offsetParent == null) {\n    offsetParent = node.parentElement;\n    while (offsetParent && !$edcf132a9284368a$var$isContainingBlock(offsetParent)) offsetParent = offsetParent.parentElement;\n  }\n  // Fall back to the viewport.\n  return offsetParent || document.documentElement;\n}\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\nfunction $edcf132a9284368a$var$isContainingBlock(node) {\n  let style = window.getComputedStyle(node);\n  return style.transform !== \"none\" || /transform|perspective/.test(style.willChange) || style.filter !== \"none\" || style.contain === \"paint\" ||\n  // @ts-ignore\n  \"backdropFilter\" in style && style.backdropFilter !== \"none\" ||\n  // @ts-ignore\n  \"WebkitBackdropFilter\" in style && style.WebkitBackdropFilter !== \"none\";\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $dd149f63282afbbf$export$f6211563215e3b37 = new WeakMap();\nfunction $dd149f63282afbbf$export$18fc8428861184da(opts) {\n  let {\n    triggerRef: triggerRef,\n    isOpen: isOpen,\n    onClose: onClose\n  } = opts;\n  (0, $k7QOs$useEffect)(() => {\n    if (!isOpen || onClose === null) return;\n    let onScroll = e => {\n      // Ignore if scrolling an scrollable region outside the trigger's tree.\n      let target = e.target;\n      // window is not a Node and doesn't have contain, but window contains everything\n      if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current)) return;\n      let onCloseHandler = onClose || $dd149f63282afbbf$export$f6211563215e3b37.get(triggerRef.current);\n      if (onCloseHandler) onCloseHandler();\n    };\n    window.addEventListener(\"scroll\", onScroll, true);\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n    };\n  }, [isOpen, onClose, triggerRef]);\n}\n\n// @ts-ignore\nlet $2a41e45df1593e64$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\nfunction $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {\n  let {\n    direction: direction\n  } = (0, $k7QOs$useLocale)();\n  let {\n    arrowSize = 0,\n    targetRef: targetRef,\n    overlayRef: overlayRef,\n    scrollRef = overlayRef,\n    placement = \"bottom\",\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== \"undefined\" ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    onClose: onClose,\n    maxHeight: maxHeight,\n    arrowBoundaryOffset = 0\n  } = props;\n  let [position, setPosition] = (0, $k7QOs$useState)({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined\n  });\n  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, maxHeight, arrowBoundaryOffset, arrowSize];\n  // Note, the position freezing breaks if body sizes itself dynamicly with the visual viewport but that might\n  // just be a non-realistic use case\n  // Upon opening a overlay, record the current visual viewport scale so we can freeze the overlay styles\n  let lastScale = (0, $k7QOs$useRef)($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale);\n  (0, $k7QOs$useEffect)(() => {\n    if (isOpen) lastScale.current = $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale;\n  }, [isOpen]);\n  let updatePosition = (0, $k7QOs$useCallback)(() => {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) return;\n    if (($2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.scale) !== lastScale.current) return;\n    // Always reset the overlay's previous max height if not defined by the user so that we can compensate for\n    // RAC collections populating after a second render and properly set a correct max height + positioning when it populates.\n    if (!maxHeight && overlayRef.current) overlayRef.current.style.maxHeight = \"none\";\n    let position = (0, $edcf132a9284368a$export$b3ceb0cbf1056d98)({\n      placement: $2a41e45df1593e64$var$translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip: shouldFlip,\n      boundaryElement: boundaryElement,\n      offset: offset,\n      crossOffset: crossOffset,\n      maxHeight: maxHeight,\n      arrowSize: arrowSize,\n      arrowBoundaryOffset: arrowBoundaryOffset\n    });\n    // Modify overlay styles directly so positioning happens immediately without the need of a second render\n    // This is so we don't have to delay autoFocus scrolling or delay applying preventScroll for popovers\n    Object.keys(position.position).forEach(key => overlayRef.current.style[key] = position.position[key] + \"px\");\n    overlayRef.current.style.maxHeight = position.maxHeight != null ? position.maxHeight + \"px\" : undefined;\n    // Trigger a set state for a second render anyway for arrow positioning\n    setPosition(position);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n  // Update position when anything changes\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  (0, $k7QOs$useLayoutEffect)(updatePosition, deps);\n  // Update position on window resize\n  $2a41e45df1593e64$var$useResize(updatePosition);\n  // Update position when the overlay changes size (might need to flip).\n  (0, $k7QOs$useResizeObserver)({\n    ref: overlayRef,\n    onResize: updatePosition\n  });\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = (0, $k7QOs$useRef)(false);\n  (0, $k7QOs$useLayoutEffect)(() => {\n    let timeout;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n    // Only reposition the overlay if a scroll event happens immediately as a result of resize (aka the virtual keyboard has appears)\n    // We don't want to reposition the overlay if the user has pinch zoomed in and is scrolling the viewport around.\n    let onScroll = () => {\n      if (isResizing.current) onResize();\n    };\n    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener(\"resize\", onResize);\n    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener(\"scroll\", onScroll);\n    return () => {\n      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener(\"resize\", onResize);\n      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener(\"scroll\", onScroll);\n    };\n  }, [updatePosition]);\n  let close = (0, $k7QOs$useCallback)(() => {\n    if (!isResizing.current) onClose();\n  }, [onClose, isResizing]);\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  (0, $dd149f63282afbbf$export$18fc8428861184da)({\n    triggerRef: targetRef,\n    isOpen: isOpen,\n    onClose: onClose && close\n  });\n  return {\n    overlayProps: {\n      style: {\n        position: \"absolute\",\n        zIndex: 100000,\n        ...position.position,\n        maxHeight: position.maxHeight\n      }\n    },\n    placement: position.placement,\n    arrowProps: {\n      \"aria-hidden\": \"true\",\n      role: \"presentation\",\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition: updatePosition\n  };\n}\nfunction $2a41e45df1593e64$var$useResize(onResize) {\n  (0, $k7QOs$useLayoutEffect)(() => {\n    window.addEventListener(\"resize\", onResize, false);\n    return () => {\n      window.removeEventListener(\"resize\", onResize, false);\n    };\n  }, [onResize]);\n}\nfunction $2a41e45df1593e64$var$translateRTL(position, direction) {\n  if (direction === \"rtl\") return position.replace(\"start\", \"right\").replace(\"end\", \"left\");\n  return position.replace(\"start\", \"left\").replace(\"end\", \"right\");\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $a11501f3d1d39e6c$var$visibleOverlays = [];\nfunction $a11501f3d1d39e6c$export$ea8f71083e90600f(props, ref) {\n  let {\n    onClose: onClose,\n    shouldCloseOnBlur: shouldCloseOnBlur,\n    isOpen: isOpen,\n    isDismissable = false,\n    isKeyboardDismissDisabled = false,\n    shouldCloseOnInteractOutside: shouldCloseOnInteractOutside\n  } = props;\n  // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.\n  (0, $k7QOs$useEffect)(() => {\n    if (isOpen) $a11501f3d1d39e6c$var$visibleOverlays.push(ref);\n    return () => {\n      let index = $a11501f3d1d39e6c$var$visibleOverlays.indexOf(ref);\n      if (index >= 0) $a11501f3d1d39e6c$var$visibleOverlays.splice(index, 1);\n    };\n  }, [isOpen, ref]);\n  // Only hide the overlay when it is the topmost visible overlay in the stack\n  let onHide = () => {\n    if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref && onClose) onClose();\n  };\n  let onInteractOutsideStart = e => {\n    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {\n      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    }\n  };\n  let onInteractOutside = e => {\n    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {\n      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n      onHide();\n    }\n  };\n  // Handle the escape key\n  let onKeyDown = e => {\n    if (e.key === \"Escape\" && !isKeyboardDismissDisabled) {\n      e.stopPropagation();\n      e.preventDefault();\n      onHide();\n    }\n  };\n  // Handle clicking outside the overlay to close it\n  (0, $k7QOs$useInteractOutside)({\n    ref: ref,\n    onInteractOutside: isDismissable && isOpen ? onInteractOutside : null,\n    onInteractOutsideStart: onInteractOutsideStart\n  });\n  let {\n    focusWithinProps: focusWithinProps\n  } = (0, $k7QOs$useFocusWithin)({\n    isDisabled: !shouldCloseOnBlur,\n    onBlurWithin: e => {\n      // Do not close if relatedTarget is null, which means focus is lost to the body.\n      // That can happen when switching tabs, or due to a VoiceOver/Chrome bug with Control+Option+Arrow navigation.\n      // Clicking on the body to close the overlay should already be handled by useInteractOutside.\n      // https://github.com/adobe/react-spectrum/issues/4130\n      // https://github.com/adobe/react-spectrum/issues/4922\n      //\n      // If focus is moving into a child focus scope (e.g. menu inside a dialog),\n      // do not close the outer overlay. At this point, the active scope should\n      // still be the outer overlay, since blur events run before focus.\n      if (!e.relatedTarget || (0, $k7QOs$isElementInChildOfActiveScope)(e.relatedTarget)) return;\n      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.relatedTarget)) onClose();\n    }\n  });\n  let onPointerDownUnderlay = e => {\n    // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846\n    if (e.target === e.currentTarget) e.preventDefault();\n  };\n  return {\n    overlayProps: {\n      onKeyDown: onKeyDown,\n      ...focusWithinProps\n    },\n    underlayProps: {\n      onPointerDown: onPointerDownUnderlay\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $628037886ba31236$export$f9d5c8beee7d008d(props, state, ref) {\n  let {\n    type: type\n  } = props;\n  let {\n    isOpen: isOpen\n  } = state;\n  // Backward compatibility. Share state close function with useOverlayPosition so it can close on scroll\n  // without forcing users to pass onClose.\n  (0, $k7QOs$useEffect)(() => {\n    if (ref && ref.current) (0, $dd149f63282afbbf$export$f6211563215e3b37).set(ref.current, state.close);\n  });\n  // Aria 1.1 supports multiple values for aria-haspopup other than just menus.\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup\n  // However, we only add it for menus for now because screen readers often\n  // announce it as a menu even for other values.\n  let ariaHasPopup = undefined;\n  if (type === \"menu\") ariaHasPopup = true;else if (type === \"listbox\") ariaHasPopup = \"listbox\";\n  let overlayId = (0, $k7QOs$useId)();\n  return {\n    triggerProps: {\n      \"aria-haspopup\": ariaHasPopup,\n      \"aria-expanded\": isOpen,\n      \"aria-controls\": isOpen ? overlayId : null,\n      onPress: state.toggle\n    },\n    overlayProps: {\n      id: overlayId\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// @ts-ignore\nconst $49c51c25361d4cd2$var$visualViewport = typeof document !== \"undefined\" && window.visualViewport;\n// HTML input types that do not cause the software keyboard to appear.\nconst $49c51c25361d4cd2$var$nonTextInputTypes = new Set([\"checkbox\", \"radio\", \"range\", \"color\", \"file\", \"image\", \"button\", \"submit\", \"reset\"]);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet $49c51c25361d4cd2$var$preventScrollCount = 0;\nlet $49c51c25361d4cd2$var$restore;\nfunction $49c51c25361d4cd2$export$ee0f7cc6afcd1c18() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    isDisabled: isDisabled\n  } = options;\n  (0, $k7QOs$useLayoutEffect)(() => {\n    if (isDisabled) return;\n    $49c51c25361d4cd2$var$preventScrollCount++;\n    if ($49c51c25361d4cd2$var$preventScrollCount === 1) {\n      if ((0, $k7QOs$isIOS)()) $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();else $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();\n    }\n    return () => {\n      $49c51c25361d4cd2$var$preventScrollCount--;\n      if ($49c51c25361d4cd2$var$preventScrollCount === 0) $49c51c25361d4cd2$var$restore();\n    };\n  }, [isDisabled]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction $49c51c25361d4cd2$var$preventScrollStandard() {\n  return (0, $k7QOs$chain)($49c51c25361d4cd2$var$setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, \"overflow\", \"hidden\"));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction $49c51c25361d4cd2$var$preventScrollMobileSafari() {\n  let scrollable;\n  let restoreScrollableStyles;\n  let onTouchStart = e => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = (0, $k7QOs$getScrollParent)(e.target, true);\n    if (scrollable === document.documentElement && scrollable === document.body) return;\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead.\n    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === \"auto\") restoreScrollableStyles = $49c51c25361d4cd2$var$setStyle(scrollable, \"overscrollBehavior\", \"contain\");\n  };\n  let onTouchMove = e => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) e.preventDefault();\n  };\n  let onTouchEnd = e => {\n    let target = e.target;\n    // Apply this change if we're not already focused on the target element\n    if ($49c51c25361d4cd2$var$willOpenKeyboard(target) && target !== document.activeElement) {\n      e.preventDefault();\n      setupStyles();\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n      // be done before the \"focus\" event, so we have to focus the element ourselves.\n      target.style.transform = \"translateY(-2000px)\";\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = \"\";\n      });\n    }\n    if (restoreScrollableStyles) restoreScrollableStyles();\n  };\n  let onFocus = e => {\n    let target = e.target;\n    if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {\n      setupStyles();\n      // Transform also needs to be applied in the focus event in cases where focus moves\n      // other than tapping on an input directly, e.g. the next/previous buttons in the\n      // software keyboard. In these cases, it seems applying the transform in the focus event\n      // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n      target.style.transform = \"translateY(-2000px)\";\n      requestAnimationFrame(() => {\n        target.style.transform = \"\";\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if ($49c51c25361d4cd2$var$visualViewport) {\n          if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight)\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              $49c51c25361d4cd2$var$scrollIntoView(target);\n            });else\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            $49c51c25361d4cd2$var$visualViewport.addEventListener(\"resize\", () => $49c51c25361d4cd2$var$scrollIntoView(target), {\n              once: true\n            });\n        }\n      });\n    }\n  };\n  let restoreStyles = null;\n  let setupStyles = () => {\n    if (restoreStyles) return;\n    let onWindowScroll = () => {\n      // Last resort. If the window scrolled, scroll it back to the top.\n      // It should always be at the top because the body will have a negative margin (see below).\n      window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    restoreStyles = (0, $k7QOs$chain)($49c51c25361d4cd2$var$addEvent(window, \"scroll\", onWindowScroll), $49c51c25361d4cd2$var$setStyle(document.documentElement, \"paddingRight\", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, \"overflow\", \"hidden\"), $49c51c25361d4cd2$var$setStyle(document.body, \"marginTop\", `-${scrollY}px`), () => {\n      window.scrollTo(scrollX, scrollY);\n    });\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n  };\n  let removeEvents = (0, $k7QOs$chain)($49c51c25361d4cd2$var$addEvent(document, \"touchstart\", onTouchStart, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, \"touchmove\", onTouchMove, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, \"touchend\", onTouchEnd, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, \"focus\", onFocus, true));\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreScrollableStyles === null || restoreScrollableStyles === void 0 ? void 0 : restoreScrollableStyles();\n    restoreStyles === null || restoreStyles === void 0 ? void 0 : restoreStyles();\n    removeEvents();\n  };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction $49c51c25361d4cd2$var$setStyle(element, style, value) {\n  let cur = element.style[style];\n  element.style[style] = value;\n  return () => {\n    element.style[style] = cur;\n  };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {\n  target.addEventListener(event, handler, options);\n  return () => {\n    target.removeEventListener(event, handler, options);\n  };\n}\nfunction $49c51c25361d4cd2$var$scrollIntoView(target) {\n  let root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = (0, $k7QOs$getScrollParent)(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = target.getBoundingClientRect().top;\n      if (targetTop > scrollableTop + target.clientHeight) scrollable.scrollTop += targetTop - scrollableTop;\n    }\n    target = scrollable.parentElement;\n  }\n}\nfunction $49c51c25361d4cd2$var$willOpenKeyboard(target) {\n  return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $f57aed4a881a3485$var$Context = /*#__PURE__*/(0, $k7QOs$react).createContext(null);\nfunction $f57aed4a881a3485$export$178405afcd8c5eb(props) {\n  let {\n    children: children\n  } = props;\n  let parent = (0, $k7QOs$useContext)($f57aed4a881a3485$var$Context);\n  let [modalCount, setModalCount] = (0, $k7QOs$useState)(0);\n  let context = (0, $k7QOs$useMemo)(() => ({\n    parent: parent,\n    modalCount: modalCount,\n    addModal() {\n      setModalCount(count => count + 1);\n      if (parent) parent.addModal();\n    },\n    removeModal() {\n      setModalCount(count => count - 1);\n      if (parent) parent.removeModal();\n    }\n  }), [parent, modalCount]);\n  return /*#__PURE__*/(0, $k7QOs$react).createElement($f57aed4a881a3485$var$Context.Provider, {\n    value: context\n  }, children);\n}\nfunction $f57aed4a881a3485$export$d9aaed4c3ece1bc0() {\n  let context = (0, $k7QOs$useContext)($f57aed4a881a3485$var$Context);\n  return {\n    modalProviderProps: {\n      \"aria-hidden\": context && context.modalCount > 0 ? true : null\n    }\n  };\n}\n/**\n * Creates a root node that will be aria-hidden if there are other modals open.\n */\nfunction $f57aed4a881a3485$var$OverlayContainerDOM(props) {\n  let {\n    modalProviderProps: modalProviderProps\n  } = $f57aed4a881a3485$export$d9aaed4c3ece1bc0();\n  return /*#__PURE__*/(0, $k7QOs$react).createElement(\"div\", {\n    \"data-overlay-container\": true,\n    ...props,\n    ...modalProviderProps\n  });\n}\nfunction $f57aed4a881a3485$export$bf688221f59024e5(props) {\n  return /*#__PURE__*/(0, $k7QOs$react).createElement($f57aed4a881a3485$export$178405afcd8c5eb, null, /*#__PURE__*/(0, $k7QOs$react).createElement($f57aed4a881a3485$var$OverlayContainerDOM, props));\n}\nfunction $f57aed4a881a3485$export$b47c3594eab58386(props) {\n  let isSSR = (0, $k7QOs$useIsSSR)();\n  let {\n    portalContainer = isSSR ? null : document.body,\n    ...rest\n  } = props;\n  (0, $k7QOs$react).useEffect(() => {\n    if (portalContainer === null || portalContainer === void 0 ? void 0 : portalContainer.closest(\"[data-overlay-container]\")) throw new Error(\"An OverlayContainer must not be inside another container. Please change the portalContainer prop.\");\n  }, [portalContainer]);\n  if (!portalContainer) return null;\n  let contents = /*#__PURE__*/(0, $k7QOs$react).createElement($f57aed4a881a3485$export$bf688221f59024e5, rest);\n  return /*#__PURE__*/(0, $k7QOs$reactdom).createPortal(contents, portalContainer);\n}\nfunction $f57aed4a881a3485$export$33ffd74ebf07f060(options) {\n  // Add aria-hidden to all parent providers on mount, and restore on unmount.\n  let context = (0, $k7QOs$useContext)($f57aed4a881a3485$var$Context);\n  if (!context) throw new Error(\"Modal is not contained within a provider\");\n  (0, $k7QOs$useEffect)(() => {\n    if ((options === null || options === void 0 ? void 0 : options.isDisabled) || !context || !context.parent) return;\n    // The immediate context is from the provider containing this modal, so we only\n    // want to trigger aria-hidden on its parents not on the modal provider itself.\n    context.parent.addModal();\n    return () => {\n      if (context && context.parent) context.parent.removeModal();\n    };\n  }, [context, context.parent, options === null || options === void 0 ? void 0 : options.isDisabled]);\n  return {\n    modalProps: {\n      \"data-ismodal\": !(options === null || options === void 0 ? void 0 : options.isDisabled)\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nvar $a2f21f5f14f60553$exports = {};\n$a2f21f5f14f60553$exports = {\n  \"ar-AE\": $773d5888b972f1cf$exports,\n  \"bg-BG\": $d11f19852b941573$exports,\n  \"cs-CZ\": $b983974c2ee1efb3$exports,\n  \"da-DK\": $5809cc9d4e92de73$exports,\n  \"de-DE\": $c68c2e4fc74398d1$exports,\n  \"el-GR\": $0898b4c153db2b77$exports,\n  \"en-US\": $6d74810286a15183$exports,\n  \"es-ES\": $309d73dc65f78055$exports,\n  \"et-EE\": $44ad94f7205cf593$exports,\n  \"fi-FI\": $7c28f5687f0779a9$exports,\n  \"fr-FR\": $e6d75df4b68bd73a$exports,\n  \"he-IL\": $87505c9dab186d0f$exports,\n  \"hr-HR\": $553439c3ffb3e492$exports,\n  \"hu-HU\": $74cf411061b983a2$exports,\n  \"it-IT\": $e933f298574dc435$exports,\n  \"ja-JP\": $ac91fc9fe02f71f6$exports,\n  \"ko-KR\": $52b96f86422025af$exports,\n  \"lt-LT\": $c0d724c3e51dafa6$exports,\n  \"lv-LV\": $c92899672a3fe72e$exports,\n  \"nb-NO\": $9f576b39d8e7a9d6$exports,\n  \"nl-NL\": $9d025808aeec81a7$exports,\n  \"pl-PL\": $fce709921e2c0fa6$exports,\n  \"pt-BR\": $2599cf0c4ab37f59$exports,\n  \"pt-PT\": $3c220ae7ef8a35fd$exports,\n  \"ro-RO\": $93562b5094072f54$exports,\n  \"ru-RU\": $cd9e2abd0d06c7b4$exports,\n  \"sk-SK\": $45375701f409adf1$exports,\n  \"sl-SI\": $27fab53a576de9dd$exports,\n  \"sr-SP\": $4438748d9952e7c7$exports,\n  \"sv-SE\": $0936d7347ef4da4c$exports,\n  \"tr-TR\": $29700c92185d38f8$exports,\n  \"uk-UA\": $662ccaf2be4c25b3$exports,\n  \"zh-CN\": $d80a27deda7cdb3c$exports,\n  \"zh-TW\": $2b2734393847c884$exports\n};\nfunction $86ea4cb521eb2e37$export$2317d149ed6f78c4(props) {\n  let {\n    onDismiss: onDismiss,\n    ...otherProps\n  } = props;\n  let stringFormatter = (0, $k7QOs$useLocalizedStringFormatter)((0, /*@__PURE__*/$parcel$interopDefault($a2f21f5f14f60553$exports)), \"@react-aria/overlays\");\n  let labels = (0, $k7QOs$useLabels)(otherProps, stringFormatter.format(\"dismiss\"));\n  let onClick = () => {\n    if (onDismiss) onDismiss();\n  };\n  return /*#__PURE__*/(0, $k7QOs$react).createElement((0, $k7QOs$VisuallyHidden), null, /*#__PURE__*/(0, $k7QOs$react).createElement(\"button\", {\n    ...labels,\n    tabIndex: -1,\n    onClick: onClick,\n    style: {\n      width: 1,\n      height: 1\n    }\n  }));\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Keeps a ref count of all hidden elements. Added to when hiding an element, and\n// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.\nlet $5e3802645cc19319$var$refCountMap = new WeakMap();\nlet $5e3802645cc19319$var$observerStack = [];\nfunction $5e3802645cc19319$export$1c3ebcada18427bf(targets) {\n  let root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;\n  let visibleNodes = new Set(targets);\n  let hiddenNodes = new Set();\n  let walk = root => {\n    // Keep live announcer and top layer elements (e.g. toasts) visible.\n    for (let element of root.querySelectorAll(\"[data-live-announcer], [data-react-aria-top-layer]\")) visibleNodes.add(element);\n    let acceptNode = node => {\n      // Skip this node and its children if it is one of the target nodes, or a live announcer.\n      // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is\n      // made for elements with role=\"row\" since VoiceOver on iOS has issues hiding elements with role=\"row\".\n      // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).\n      if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute(\"role\") !== \"row\") return NodeFilter.FILTER_REJECT;\n      // Skip this node but continue to children if one of the targets is inside the node.\n      for (let target of visibleNodes) {\n        if (node.contains(target)) return NodeFilter.FILTER_SKIP;\n      }\n      return NodeFilter.FILTER_ACCEPT;\n    };\n    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: acceptNode\n    });\n    // TreeWalker does not include the root.\n    let acceptRoot = acceptNode(root);\n    if (acceptRoot === NodeFilter.FILTER_ACCEPT) hide(root);\n    if (acceptRoot !== NodeFilter.FILTER_REJECT) {\n      let node = walker.nextNode();\n      while (node != null) {\n        hide(node);\n        node = walker.nextNode();\n      }\n    }\n  };\n  let hide = node => {\n    var _refCountMap_get;\n    let refCount = (_refCountMap_get = $5e3802645cc19319$var$refCountMap.get(node)) !== null && _refCountMap_get !== void 0 ? _refCountMap_get : 0;\n    // If already aria-hidden, and the ref count is zero, then this element\n    // was already hidden and there's nothing for us to do.\n    if (node.getAttribute(\"aria-hidden\") === \"true\" && refCount === 0) return;\n    if (refCount === 0) node.setAttribute(\"aria-hidden\", \"true\");\n    hiddenNodes.add(node);\n    $5e3802645cc19319$var$refCountMap.set(node, refCount + 1);\n  };\n  // If there is already a MutationObserver listening from a previous call,\n  // disconnect it so the new on takes over.\n  if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].disconnect();\n  walk(root);\n  let observer = new MutationObserver(changes => {\n    for (let change of changes) {\n      if (change.type !== \"childList\" || change.addedNodes.length === 0) continue;\n      // If the parent element of the added nodes is not within one of the targets,\n      // and not already inside a hidden node, hide all of the new children.\n      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {\n        for (let node of change.removedNodes) if (node instanceof Element) {\n          visibleNodes.delete(node);\n          hiddenNodes.delete(node);\n        }\n        for (let node of change.addedNodes) {\n          if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === \"true\" || node.dataset.reactAriaTopLayer === \"true\")) visibleNodes.add(node);else if (node instanceof Element) walk(node);\n        }\n      }\n    }\n  });\n  observer.observe(root, {\n    childList: true,\n    subtree: true\n  });\n  let observerWrapper = {\n    observe() {\n      observer.observe(root, {\n        childList: true,\n        subtree: true\n      });\n    },\n    disconnect() {\n      observer.disconnect();\n    }\n  };\n  $5e3802645cc19319$var$observerStack.push(observerWrapper);\n  return () => {\n    observer.disconnect();\n    for (let node of hiddenNodes) {\n      let count = $5e3802645cc19319$var$refCountMap.get(node);\n      if (count === 1) {\n        node.removeAttribute(\"aria-hidden\");\n        $5e3802645cc19319$var$refCountMap.delete(node);\n      } else $5e3802645cc19319$var$refCountMap.set(node, count - 1);\n    }\n    // Remove this observer from the stack, and start the previous one.\n    if (observerWrapper === $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1]) {\n      $5e3802645cc19319$var$observerStack.pop();\n      if ($5e3802645cc19319$var$observerStack.length) $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].observe();\n    } else $5e3802645cc19319$var$observerStack.splice($5e3802645cc19319$var$observerStack.indexOf(observerWrapper), 1);\n  };\n}\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $f2f8a6077418541e$export$542a6fd13ac93354(props, state) {\n  let {\n    triggerRef: triggerRef,\n    popoverRef: popoverRef,\n    isNonModal: isNonModal,\n    isKeyboardDismissDisabled: isKeyboardDismissDisabled,\n    shouldCloseOnInteractOutside: shouldCloseOnInteractOutside,\n    ...otherProps\n  } = props;\n  let {\n    overlayProps: overlayProps,\n    underlayProps: underlayProps\n  } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({\n    isOpen: state.isOpen,\n    onClose: state.close,\n    shouldCloseOnBlur: true,\n    isDismissable: !isNonModal,\n    isKeyboardDismissDisabled: isKeyboardDismissDisabled,\n    shouldCloseOnInteractOutside: shouldCloseOnInteractOutside\n  }, popoverRef);\n  let {\n    overlayProps: positionProps,\n    arrowProps: arrowProps,\n    placement: placement\n  } = (0, $2a41e45df1593e64$export$d39e1813b3bdd0e1)({\n    ...otherProps,\n    targetRef: triggerRef,\n    overlayRef: popoverRef,\n    isOpen: state.isOpen,\n    onClose: isNonModal ? state.close : null\n  });\n  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({\n    isDisabled: isNonModal || !state.isOpen\n  });\n  (0, $k7QOs$useLayoutEffect)(() => {\n    if (state.isOpen && !isNonModal && popoverRef.current) return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([popoverRef.current]);\n  }, [isNonModal, state.isOpen, popoverRef]);\n  return {\n    popoverProps: (0, $k7QOs$mergeProps)(overlayProps, positionProps),\n    arrowProps: arrowProps,\n    underlayProps: underlayProps,\n    placement: placement\n  };\n}\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $337b884510726a0d$export$a2200b96afd16271 = /*#__PURE__*/(0, $k7QOs$react).createContext(null);\nfunction $337b884510726a0d$export$c6fdb837b070b4ff(props) {\n  let isSSR = (0, $k7QOs$useIsSSR)();\n  let {\n    portalContainer = isSSR ? null : document.body,\n    isExiting: isExiting\n  } = props;\n  let [contain, setContain] = (0, $k7QOs$useState)(false);\n  let contextValue = (0, $k7QOs$useMemo)(() => ({\n    contain: contain,\n    setContain: setContain\n  }), [contain, setContain]);\n  if (!portalContainer) return null;\n  let contents = props.children;\n  if (!props.disableFocusManagement) contents = /*#__PURE__*/(0, $k7QOs$react).createElement((0, $k7QOs$FocusScope), {\n    restoreFocus: true,\n    contain: contain && !isExiting\n  }, contents);\n  contents = /*#__PURE__*/(0, $k7QOs$react).createElement($337b884510726a0d$export$a2200b96afd16271.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/(0, $k7QOs$react).createElement((0, $k7QOs$ClearPressResponder), null, contents));\n  return /*#__PURE__*/(0, $k7QOs$reactdom).createPortal(contents, portalContainer);\n}\nfunction $337b884510726a0d$export$14c98a7594375490() {\n  let ctx = (0, $k7QOs$useContext)($337b884510726a0d$export$a2200b96afd16271);\n  let setContain = ctx === null || ctx === void 0 ? void 0 : ctx.setContain;\n  (0, $k7QOs$useLayoutEffect)(() => {\n    setContain === null || setContain === void 0 ? void 0 : setContain(true);\n  }, [setContain]);\n}\nfunction $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, ref) {\n  let {\n    overlayProps: overlayProps,\n    underlayProps: underlayProps\n  } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({\n    ...props,\n    isOpen: state.isOpen,\n    onClose: state.close\n  }, ref);\n  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({\n    isDisabled: !state.isOpen\n  });\n  (0, $337b884510726a0d$export$14c98a7594375490)();\n  (0, $k7QOs$useEffect)(() => {\n    if (state.isOpen) return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([ref.current]);\n  }, [state.isOpen, ref]);\n  return {\n    modalProps: (0, $k7QOs$mergeProps)(overlayProps),\n    underlayProps: underlayProps\n  };\n}\nexport { $2a41e45df1593e64$export$d39e1813b3bdd0e1 as useOverlayPosition, $a11501f3d1d39e6c$export$ea8f71083e90600f as useOverlay, $628037886ba31236$export$f9d5c8beee7d008d as useOverlayTrigger, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18 as usePreventScroll, $f57aed4a881a3485$export$178405afcd8c5eb as ModalProvider, $f57aed4a881a3485$export$d9aaed4c3ece1bc0 as useModalProvider, $f57aed4a881a3485$export$bf688221f59024e5 as OverlayProvider, $f57aed4a881a3485$export$b47c3594eab58386 as OverlayContainer, $f57aed4a881a3485$export$33ffd74ebf07f060 as useModal, $86ea4cb521eb2e37$export$2317d149ed6f78c4 as DismissButton, $5e3802645cc19319$export$1c3ebcada18427bf as ariaHideOutside, $f2f8a6077418541e$export$542a6fd13ac93354 as usePopover, $8ac8429251c45e4b$export$dbc0f175b25fb0fb as useModalOverlay, $337b884510726a0d$export$c6fdb837b070b4ff as Overlay, $337b884510726a0d$export$14c98a7594375490 as useOverlayFocusContain };","map":{"version":3,"names":["$edcf132a9284368a$var$AXIS","top","bottom","left","right","$edcf132a9284368a$var$FLIPPED_DIRECTION","$edcf132a9284368a$var$CROSS_AXIS","$edcf132a9284368a$var$AXIS_SIZE","$edcf132a9284368a$var$TOTAL_SIZE","width","height","$edcf132a9284368a$var$PARSED_PLACEMENT_CACHE","$edcf132a9284368a$var$visualViewport","document","window","visualViewport","$edcf132a9284368a$var$getContainerDimensions","containerNode","totalWidth","totalHeight","scroll","isPinchZoomedIn","scale","tagName","documentElement","clientWidth","clientHeight","_visualViewport_width","_visualViewport_height","scrollTop","scrollLeft","offsetTop","offsetLeft","$edcf132a9284368a$var$getOffset","$k7QOs$isWebKit","pageTop","pageLeft","$edcf132a9284368a$var$getScroll","node","scrollWidth","scrollHeight","$edcf132a9284368a$var$getDelta","axis","offset","size","boundaryDimensions","containerDimensions","padding","containerOffsetWithBoundary","containerScroll","boundarySize","boundaryStartEdge","boundaryEndEdge","startEdgeOffset","endEdgeOffset","Math","max","$edcf132a9284368a$var$getMargins","style","getComputedStyle","parseInt","marginTop","marginBottom","marginLeft","marginRight","$edcf132a9284368a$var$parsePlacement","input","placement","crossPlacement","split","crossAxis","crossSize","$edcf132a9284368a$var$computePosition","childOffset","overlaySize","placementInfo","crossOffset","isContainerPositioned","arrowSize","arrowBoundaryOffset","position","minPosition","maxPosition","$k7QOs$clamp","containerHeight","floor","$edcf132a9284368a$var$getMaxHeight","margins","overlayHeight","heightGrowthDirection","overlayTop","maxHeight","min","$edcf132a9284368a$var$getAvailableSpace","$edcf132a9284368a$export$6839422d1f33cee9","placementInput","scrollSize","flip","userSetMaxHeight","normalizedOffset","space","flippedPlacementInfo","flippedPosition","flippedSpace","delta","arrowPosition","preferredArrowPosition","arrowMinPosition","arrowMaxPosition","arrowOverlappingChildMinEdge","arrowOverlappingChildMaxEdge","arrowPositionOverlappingChild","arrowOffsetLeft","arrowOffsetTop","$edcf132a9284368a$export$b3ceb0cbf1056d98","opts","targetNode","overlayNode","scrollNode","shouldFlip","boundaryElement","container","HTMLElement","$edcf132a9284368a$var$getContainingBlock","isViewportContainer","containerPositionStyle","$edcf132a9284368a$var$getPosition","getBoundingClientRect","clientTop","clientLeft","parent","parentOffset","parentStyle","borderTopWidth","borderLeftWidth","offsetParent","body","$edcf132a9284368a$var$isContainingBlock","parentElement","transform","test","willChange","filter","contain","backdropFilter","WebkitBackdropFilter","$dd149f63282afbbf$export$f6211563215e3b37","WeakMap","$dd149f63282afbbf$export$18fc8428861184da","triggerRef","isOpen","onClose","$k7QOs$useEffect","onScroll","e","target","current","Node","contains","onCloseHandler","get","addEventListener","removeEventListener","$2a41e45df1593e64$var$visualViewport","$2a41e45df1593e64$export$d39e1813b3bdd0e1","props","direction","$k7QOs$useLocale","targetRef","overlayRef","scrollRef","containerPadding","shouldUpdatePosition","setPosition","$k7QOs$useState","undefined","deps","lastScale","$k7QOs$useRef","updatePosition","$k7QOs$useCallback","$2a41e45df1593e64$var$translateRTL","Object","keys","forEach","key","$k7QOs$useLayoutEffect","$2a41e45df1593e64$var$useResize","$k7QOs$useResizeObserver","ref","onResize","isResizing","timeout","clearTimeout","setTimeout","close","overlayProps","zIndex","arrowProps","role","replace","$a11501f3d1d39e6c$var$visibleOverlays","$a11501f3d1d39e6c$export$ea8f71083e90600f","shouldCloseOnBlur","isDismissable","isKeyboardDismissDisabled","shouldCloseOnInteractOutside","push","index","indexOf","splice","onHide","length","onInteractOutsideStart","stopPropagation","preventDefault","onInteractOutside","onKeyDown","$k7QOs$useInteractOutside","focusWithinProps","$k7QOs$useFocusWithin","isDisabled","onBlurWithin","relatedTarget","$k7QOs$isElementInChildOfActiveScope","onPointerDownUnderlay","currentTarget","underlayProps","onPointerDown","$628037886ba31236$export$f9d5c8beee7d008d","state","type","set","ariaHasPopup","overlayId","$k7QOs$useId","triggerProps","onPress","toggle","id","$49c51c25361d4cd2$var$visualViewport","$49c51c25361d4cd2$var$nonTextInputTypes","Set","$49c51c25361d4cd2$var$preventScrollCount","$49c51c25361d4cd2$var$restore","$49c51c25361d4cd2$export$ee0f7cc6afcd1c18","options","arguments","$k7QOs$isIOS","$49c51c25361d4cd2$var$preventScrollMobileSafari","$49c51c25361d4cd2$var$preventScrollStandard","$k7QOs$chain","$49c51c25361d4cd2$var$setStyle","innerWidth","scrollable","restoreScrollableStyles","onTouchStart","$k7QOs$getScrollParent","overscrollBehavior","onTouchMove","onTouchEnd","$49c51c25361d4cd2$var$willOpenKeyboard","activeElement","setupStyles","focus","requestAnimationFrame","onFocus","innerHeight","$49c51c25361d4cd2$var$scrollIntoView","once","restoreStyles","onWindowScroll","scrollTo","scrollX","pageXOffset","scrollY","pageYOffset","$49c51c25361d4cd2$var$addEvent","removeEvents","passive","capture","element","value","cur","event","handler","root","scrollingElement","scrollableTop","targetTop","HTMLInputElement","has","HTMLTextAreaElement","isContentEditable","$f57aed4a881a3485$var$Context","$k7QOs$react","createContext","$f57aed4a881a3485$export$178405afcd8c5eb","children","$k7QOs$useContext","modalCount","setModalCount","context","$k7QOs$useMemo","addModal","count","removeModal","createElement","Provider","$f57aed4a881a3485$export$d9aaed4c3ece1bc0","modalProviderProps","$f57aed4a881a3485$var$OverlayContainerDOM","$f57aed4a881a3485$export$bf688221f59024e5","$f57aed4a881a3485$export$b47c3594eab58386","isSSR","$k7QOs$useIsSSR","portalContainer","rest","useEffect","closest","Error","contents","$k7QOs$reactdom","createPortal","$f57aed4a881a3485$export$33ffd74ebf07f060","modalProps","$a2f21f5f14f60553$exports","$773d5888b972f1cf$exports","$d11f19852b941573$exports","$b983974c2ee1efb3$exports","$5809cc9d4e92de73$exports","$c68c2e4fc74398d1$exports","$0898b4c153db2b77$exports","$6d74810286a15183$exports","$309d73dc65f78055$exports","$44ad94f7205cf593$exports","$7c28f5687f0779a9$exports","$e6d75df4b68bd73a$exports","$87505c9dab186d0f$exports","$553439c3ffb3e492$exports","$74cf411061b983a2$exports","$e933f298574dc435$exports","$ac91fc9fe02f71f6$exports","$52b96f86422025af$exports","$c0d724c3e51dafa6$exports","$c92899672a3fe72e$exports","$9f576b39d8e7a9d6$exports","$9d025808aeec81a7$exports","$fce709921e2c0fa6$exports","$2599cf0c4ab37f59$exports","$3c220ae7ef8a35fd$exports","$93562b5094072f54$exports","$cd9e2abd0d06c7b4$exports","$45375701f409adf1$exports","$27fab53a576de9dd$exports","$4438748d9952e7c7$exports","$0936d7347ef4da4c$exports","$29700c92185d38f8$exports","$662ccaf2be4c25b3$exports","$d80a27deda7cdb3c$exports","$2b2734393847c884$exports","$86ea4cb521eb2e37$export$2317d149ed6f78c4","onDismiss","otherProps","stringFormatter","$k7QOs$useLocalizedStringFormatter","$parcel$interopDefault","labels","$k7QOs$useLabels","format","onClick","$k7QOs$VisuallyHidden","tabIndex","$5e3802645cc19319$var$refCountMap","$5e3802645cc19319$var$observerStack","$5e3802645cc19319$export$1c3ebcada18427bf","targets","visibleNodes","hiddenNodes","walk","querySelectorAll","add","acceptNode","getAttribute","NodeFilter","FILTER_REJECT","FILTER_SKIP","FILTER_ACCEPT","walker","createTreeWalker","SHOW_ELEMENT","acceptRoot","hide","nextNode","_refCountMap_get","refCount","setAttribute","disconnect","observer","MutationObserver","changes","change","addedNodes","some","removedNodes","Element","delete","SVGElement","dataset","liveAnnouncer","reactAriaTopLayer","observe","childList","subtree","observerWrapper","removeAttribute","pop","$f2f8a6077418541e$export$542a6fd13ac93354","popoverRef","isNonModal","positionProps","popoverProps","$k7QOs$mergeProps","$337b884510726a0d$export$a2200b96afd16271","$337b884510726a0d$export$c6fdb837b070b4ff","isExiting","setContain","contextValue","disableFocusManagement","$k7QOs$FocusScope","restoreFocus","$k7QOs$ClearPressResponder","$337b884510726a0d$export$14c98a7594375490","ctx","$8ac8429251c45e4b$export$dbc0f175b25fb0fb"],"sources":["D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\index.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\useOverlayPosition.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\calculatePosition.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\useCloseOnScroll.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\useOverlay.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\useOverlayTrigger.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\usePreventScroll.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\useModal.tsx","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\DismissButton.tsx","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\*.js","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\ariaHideOutside.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\usePopover.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\useModalOverlay.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\Overlay.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport {useOverlayPosition} from './useOverlayPosition';\nexport {useOverlay} from './useOverlay';\nexport {useOverlayTrigger} from './useOverlayTrigger';\nexport {usePreventScroll} from './usePreventScroll';\nexport {ModalProvider, useModalProvider, OverlayProvider, OverlayContainer, useModal} from './useModal';\nexport {DismissButton} from './DismissButton';\nexport {ariaHideOutside} from './ariaHideOutside';\nexport {usePopover} from './usePopover';\nexport {useModalOverlay} from './useModalOverlay';\nexport {Overlay, useOverlayFocusContain} from './Overlay';\n\nexport type {AriaPositionProps, PositionAria} from './useOverlayPosition';\nexport type {AriaOverlayProps, OverlayAria} from './useOverlay';\nexport type {OverlayTriggerAria, OverlayTriggerProps} from './useOverlayTrigger';\nexport type {AriaModalOptions, ModalAria, ModalProviderAria, ModalProviderProps, OverlayContainerProps} from './useModal';\nexport type {DismissButtonProps} from './DismissButton';\nexport type {AriaPopoverProps, PopoverAria} from './usePopover';\nexport type {AriaModalOverlayProps, ModalOverlayAria} from './useModalOverlay';\nexport type {OverlayProps} from './Overlay';\nexport type {Placement, PlacementAxis, PositionProps} from '@react-types/overlays';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {calculatePosition, PositionResult} from './calculatePosition';\nimport {DOMAttributes} from '@react-types/shared';\nimport {Placement, PlacementAxis, PositionProps} from '@react-types/overlays';\nimport {RefObject, useCallback, useEffect, useRef, useState} from 'react';\nimport {useCloseOnScroll} from './useCloseOnScroll';\nimport {useLayoutEffect, useResizeObserver} from '@react-aria/utils';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface AriaPositionProps extends PositionProps {\n  /**\n   * Cross size of the overlay arrow in pixels.\n   * @default 0\n   */\n  arrowSize?: number,\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: Element,\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<Element>,\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<Element>,\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<Element>,\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean,\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void,\n  /**\n   * The maxHeight specified for the overlay element.\n   * By default, it will take all space up to the current viewport height.\n   */\n  maxHeight?: number,\n  /**\n   * The minimum distance the arrow's edge should be from the edge of the overlay element.\n   * @default 0\n   */\n  arrowBoundaryOffset?: number\n}\n\nexport interface PositionAria {\n  /** Props for the overlay container element. */\n  overlayProps: DOMAttributes,\n  /** Props for the overlay tip arrow if any. */\n  arrowProps: DOMAttributes,\n  /** Placement of the overlay with respect to the overlay trigger. */\n  placement: PlacementAxis,\n  /** Updates the position of the overlay. */\n  updatePosition(): void\n}\n\n// @ts-ignore\nlet visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\n  let {direction} = useLocale();\n  let {\n    arrowSize = 0,\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom' as Placement,\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    onClose,\n    maxHeight,\n    arrowBoundaryOffset = 0\n  } = props;\n  let [position, setPosition] = useState<PositionResult>({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined\n  });\n\n  let deps = [\n    shouldUpdatePosition,\n    placement,\n    overlayRef.current,\n    targetRef.current,\n    scrollRef.current,\n    containerPadding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    isOpen,\n    direction,\n    maxHeight,\n    arrowBoundaryOffset,\n    arrowSize\n  ];\n\n  // Note, the position freezing breaks if body sizes itself dynamicly with the visual viewport but that might\n  // just be a non-realistic use case\n  // Upon opening a overlay, record the current visual viewport scale so we can freeze the overlay styles\n  let lastScale = useRef(visualViewport?.scale);\n  useEffect(() => {\n    if (isOpen) {\n      lastScale.current = visualViewport?.scale;\n    }\n  }, [isOpen]);\n\n  let updatePosition = useCallback(() => {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {\n      return;\n    }\n\n    if (visualViewport?.scale !== lastScale.current) {\n      return;\n    }\n\n    // Always reset the overlay's previous max height if not defined by the user so that we can compensate for\n    // RAC collections populating after a second render and properly set a correct max height + positioning when it populates.\n    if (!maxHeight && overlayRef.current) {\n      (overlayRef.current as HTMLElement).style.maxHeight = 'none';\n    }\n\n    let position = calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip,\n      boundaryElement,\n      offset,\n      crossOffset,\n      maxHeight,\n      arrowSize,\n      arrowBoundaryOffset\n    });\n\n    // Modify overlay styles directly so positioning happens immediately without the need of a second render\n    // This is so we don't have to delay autoFocus scrolling or delay applying preventScroll for popovers\n    Object.keys(position.position).forEach(key => (overlayRef.current as HTMLElement).style[key] = position.position[key] + 'px');\n    (overlayRef.current as HTMLElement).style.maxHeight = position.maxHeight != null ?  position.maxHeight + 'px' : undefined;\n\n    // Trigger a set state for a second render anyway for arrow positioning\n    setPosition(position);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  // Update position when anything changes\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useLayoutEffect(updatePosition, deps);\n\n  // Update position on window resize\n  useResize(updatePosition);\n\n  // Update position when the overlay changes size (might need to flip).\n  useResizeObserver({\n    ref: overlayRef,\n    onResize: updatePosition\n  });\n\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout: ReturnType<typeof setTimeout>;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n\n      updatePosition();\n    };\n\n    // Only reposition the overlay if a scroll event happens immediately as a result of resize (aka the virtual keyboard has appears)\n    // We don't want to reposition the overlay if the user has pinch zoomed in and is scrolling the viewport around.\n    let onScroll = () => {\n      if (isResizing.current) {\n        onResize();\n      }\n    };\n\n    visualViewport?.addEventListener('resize', onResize);\n    visualViewport?.addEventListener('scroll', onScroll);\n    return () => {\n      visualViewport?.removeEventListener('resize', onResize);\n      visualViewport?.removeEventListener('scroll', onScroll);\n    };\n  }, [updatePosition]);\n\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose && close\n  });\n\n  return {\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000, // should match the z-index in ModalTrigger\n        ...position.position,\n        maxHeight: position.maxHeight\n      }\n    },\n    placement: position.placement,\n    arrowProps: {\n      'aria-hidden': 'true',\n      role: 'presentation',\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Axis, Placement, PlacementAxis, SizeAxis} from '@react-types/overlays';\nimport {clamp, isWebKit} from '@react-aria/utils';\n\ninterface Position {\n  top?: number,\n  left?: number,\n  bottom?: number,\n  right?: number\n}\n\ninterface Dimensions {\n  width: number,\n  height: number,\n  totalWidth: number,\n  totalHeight: number,\n  top: number,\n  left: number,\n  scroll: Position\n}\n\ninterface ParsedPlacement {\n  placement: PlacementAxis,\n  crossPlacement: PlacementAxis,\n  axis: Axis,\n  crossAxis: Axis,\n  size: SizeAxis,\n  crossSize: SizeAxis\n}\n\ninterface Offset {\n  top: number,\n  left: number,\n  width: number,\n  height: number\n}\n\ninterface PositionOpts {\n  arrowSize: number,\n  placement: Placement,\n  targetNode: Element,\n  overlayNode: Element,\n  scrollNode: Element,\n  padding: number,\n  shouldFlip: boolean,\n  boundaryElement: Element,\n  offset: number,\n  crossOffset: number,\n  maxHeight?: number,\n  arrowBoundaryOffset?: number\n}\n\ntype HeightGrowthDirection = 'top' | 'bottom';\n\nexport interface PositionResult {\n  position?: Position,\n  arrowOffsetLeft?: number,\n  arrowOffsetTop?: number,\n  maxHeight?: number,\n  placement: PlacementAxis\n}\n\nconst AXIS = {\n  top: 'top',\n  bottom: 'top',\n  left: 'left',\n  right: 'left'\n};\n\nconst FLIPPED_DIRECTION = {\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left'\n};\n\nconst CROSS_AXIS = {\n  top: 'left',\n  left: 'top'\n};\n\nconst AXIS_SIZE = {\n  top: 'height',\n  left: 'width'\n};\n\nconst TOTAL_SIZE = {\n  width: 'totalWidth',\n  height: 'totalHeight'\n};\n\nconst PARSED_PLACEMENT_CACHE = {};\n\n// @ts-ignore\nlet visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\nfunction getContainerDimensions(containerNode: Element): Dimensions {\n  let width = 0, height = 0, totalWidth = 0, totalHeight = 0, top = 0, left = 0;\n  let scroll: Position = {};\n  let isPinchZoomedIn = visualViewport?.scale > 1;\n\n  if (containerNode.tagName === 'BODY') {\n    let documentElement = document.documentElement;\n    totalWidth = documentElement.clientWidth;\n    totalHeight = documentElement.clientHeight;\n    width = visualViewport?.width ?? totalWidth;\n    height = visualViewport?.height ?? totalHeight;\n    scroll.top = documentElement.scrollTop || containerNode.scrollTop;\n    scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;\n\n    // The goal of the below is to get a top/left value that represents the top/left of the visual viewport with\n    // respect to the layout viewport origin. This combined with the scrollTop/scrollLeft will allow us to calculate\n    // coordinates/values with respect to the visual viewport or with respect to the layout viewport.\n    if (visualViewport) {\n      top = visualViewport.offsetTop;\n      left = visualViewport.offsetLeft;\n    }\n  } else {\n    ({width, height, top, left} = getOffset(containerNode));\n    scroll.top = containerNode.scrollTop;\n    scroll.left = containerNode.scrollLeft;\n    totalWidth = width;\n    totalHeight = height;\n  }\n\n  if (isWebKit() && (containerNode.tagName === 'BODY' || containerNode.tagName === 'HTML') && isPinchZoomedIn) {\n    // Safari will report a non-zero scrollTop/Left for the non-scrolling body/HTML element when pinch zoomed in unlike other browsers.\n    // Set to zero for parity calculations so we get consistent positioning of overlays across all browsers.\n    // Also switch to visualViewport.pageTop/pageLeft so that we still accomodate for scroll positioning for body/HTML elements that are actually scrollable\n    // before pinch zoom happens\n    scroll.top = 0;\n    scroll.left = 0;\n    top = visualViewport.pageTop;\n    left = visualViewport.pageLeft;\n  }\n\n  return {width, height, totalWidth, totalHeight, scroll, top, left};\n}\n\nfunction getScroll(node: Element): Offset {\n  return {\n    top: node.scrollTop,\n    left: node.scrollLeft,\n    width: node.scrollWidth,\n    height: node.scrollHeight\n  };\n}\n\n// Determines the amount of space required when moving the overlay to ensure it remains in the boundary\nfunction getDelta(\n  axis: Axis,\n  offset: number,\n  size: number,\n  // The dimensions of the boundary element that the popover is\n  // positioned within (most of the time this is the <body>).\n  boundaryDimensions: Dimensions,\n  // The dimensions of the containing block element that the popover is\n  // positioned relative to (e.g. parent with position: relative).\n  // Usually this is the same as the boundary element, but if the popover\n  // is portaled somewhere other than the body and has an ancestor with\n  // position: relative/absolute, it will be different.\n  containerDimensions: Dimensions,\n  padding: number,\n  containerOffsetWithBoundary: Offset\n) {\n  let containerScroll = containerDimensions.scroll[axis];\n  // The height/width of the boundary. Matches the axis along which we are adjusting the overlay position\n  let boundarySize = boundaryDimensions[AXIS_SIZE[axis]];\n  // Calculate the edges of the boundary (accomodating for the boundary padding) and the edges of the overlay.\n  // Note that these values are with respect to the visual viewport (aka 0,0 is the top left of the viewport)\n  let boundaryStartEdge = boundaryDimensions.scroll[AXIS[axis]] + padding;\n  let boundaryEndEdge = boundarySize + boundaryDimensions.scroll[AXIS[axis]] - padding;\n  let startEdgeOffset = offset - containerScroll + containerOffsetWithBoundary[axis] - boundaryDimensions[AXIS[axis]];\n  let endEdgeOffset = offset - containerScroll + size + containerOffsetWithBoundary[axis] - boundaryDimensions[AXIS[axis]];\n\n  // If any of the overlay edges falls outside of the boundary, shift the overlay the required amount to align one of the overlay's\n  // edges with the closest boundary edge.\n  if (startEdgeOffset < boundaryStartEdge) {\n    return boundaryStartEdge - startEdgeOffset;\n  } else if (endEdgeOffset > boundaryEndEdge) {\n    return Math.max(boundaryEndEdge - endEdgeOffset, boundaryStartEdge - startEdgeOffset);\n  } else {\n    return 0;\n  }\n}\n\nfunction getMargins(node: Element): Position {\n  let style = window.getComputedStyle(node);\n  return {\n    top: parseInt(style.marginTop, 10) || 0,\n    bottom: parseInt(style.marginBottom, 10) || 0,\n    left: parseInt(style.marginLeft, 10) || 0,\n    right: parseInt(style.marginRight, 10) || 0\n  };\n}\n\nfunction parsePlacement(input: Placement): ParsedPlacement {\n  if (PARSED_PLACEMENT_CACHE[input]) {\n    return PARSED_PLACEMENT_CACHE[input];\n  }\n\n  let [placement, crossPlacement] = input.split(' ');\n  let axis: Axis = AXIS[placement] || 'right';\n  let crossAxis: Axis = CROSS_AXIS[axis];\n\n  if (!AXIS[crossPlacement]) {\n    crossPlacement = 'center';\n  }\n\n  let size = AXIS_SIZE[axis];\n  let crossSize = AXIS_SIZE[crossAxis];\n  PARSED_PLACEMENT_CACHE[input] = {placement, crossPlacement, axis, crossAxis, size, crossSize};\n  return PARSED_PLACEMENT_CACHE[input];\n}\n\nfunction computePosition(\n  childOffset: Offset,\n  boundaryDimensions: Dimensions,\n  overlaySize: Offset,\n  placementInfo: ParsedPlacement,\n  offset: number,\n  crossOffset: number,\n  containerOffsetWithBoundary: Offset,\n  isContainerPositioned: boolean,\n  arrowSize: number,\n  arrowBoundaryOffset: number\n) {\n  let {placement, crossPlacement, axis, crossAxis, size, crossSize} = placementInfo;\n  let position: Position = {};\n\n  // button position\n  position[crossAxis] = childOffset[crossAxis];\n  if (crossPlacement === 'center') {\n    //  + (button size / 2) - (overlay size / 2)\n    // at this point the overlay center should match the button center\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;\n  } else if (crossPlacement !== crossAxis) {\n    //  + (button size) - (overlay size)\n    // at this point the overlay bottom should match the button bottom\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]);\n  }/* else {\n    the overlay top should match the button top\n  } */\n\n  position[crossAxis] += crossOffset;\n\n  // overlay top overlapping arrow with button bottom\n  const minPosition = childOffset[crossAxis] - overlaySize[crossSize] + arrowSize + arrowBoundaryOffset;\n  // overlay bottom overlapping arrow with button top\n  const maxPosition = childOffset[crossAxis] + childOffset[crossSize] - arrowSize - arrowBoundaryOffset;\n  position[crossAxis] = clamp(position[crossAxis], minPosition, maxPosition);\n\n  // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.\n  if (placement === axis) {\n    // If the container is positioned (non-static), then we use the container's actual\n    // height, as `bottom` will be relative to this height.  But if the container is static,\n    // then it can only be the `document.body`, and `bottom` will be relative to _its_\n    // container, which should be as large as boundaryDimensions.\n    const containerHeight = (isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[TOTAL_SIZE[size]]);\n    position[FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);\n  } else {\n    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n  }\n  return position;\n}\n\nfunction getMaxHeight(\n  position: Position,\n  boundaryDimensions: Dimensions,\n  containerOffsetWithBoundary: Offset,\n  isContainerPositioned: boolean,\n  margins: Position,\n  padding: number,\n  overlayHeight: number,\n  heightGrowthDirection: HeightGrowthDirection\n) {\n  const containerHeight = (isContainerPositioned ? containerOffsetWithBoundary.height : boundaryDimensions[TOTAL_SIZE.height]);\n  // For cases where position is set via \"bottom\" instead of \"top\", we need to calculate the true overlay top with respect to the boundary. Reverse calculate this with the same method\n  // used in computePosition.\n  let overlayTop = position.top != null ? containerOffsetWithBoundary.top + position.top : containerOffsetWithBoundary.top + (containerHeight - position.bottom - overlayHeight);\n  let maxHeight = heightGrowthDirection !== 'top' ?\n    // We want the distance between the top of the overlay to the bottom of the boundary\n    Math.max(0,\n      (boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top) // this is the bottom of the boundary\n      - overlayTop // this is the top of the overlay\n      - (margins.top + margins.bottom + padding) // save additional space for margin and padding\n    )\n    // We want the distance between the bottom of the overlay to the top of the boundary\n    : Math.max(0,\n      (overlayTop + overlayHeight) // this is the bottom of the overlay\n      - (boundaryDimensions.top + boundaryDimensions.scroll.top) // this is the top of the boundary\n      - (margins.top + margins.bottom + padding) // save additional space for margin and padding\n    );\n  return Math.min(boundaryDimensions.height - (padding * 2), maxHeight);\n}\n\nfunction getAvailableSpace(\n  boundaryDimensions: Dimensions,\n  containerOffsetWithBoundary: Offset,\n  childOffset: Offset,\n  margins: Position,\n  padding: number,\n  placementInfo: ParsedPlacement\n) {\n  let {placement, axis, size} = placementInfo;\n  if (placement === axis) {\n    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[FLIPPED_DIRECTION[axis]] - padding);\n  }\n\n  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[FLIPPED_DIRECTION[axis]] - padding);\n}\n\nexport function calculatePositionInternal(\n  placementInput: Placement,\n  childOffset: Offset,\n  overlaySize: Offset,\n  scrollSize: Offset,\n  margins: Position,\n  padding: number,\n  flip: boolean,\n  boundaryDimensions: Dimensions,\n  containerDimensions: Dimensions,\n  containerOffsetWithBoundary: Offset,\n  offset: number,\n  crossOffset: number,\n  isContainerPositioned: boolean,\n  userSetMaxHeight: number | undefined,\n  arrowSize: number,\n  arrowBoundaryOffset: number\n): PositionResult {\n  let placementInfo = parsePlacement(placementInput);\n  let {size, crossAxis, crossSize, placement, crossPlacement} = placementInfo;\n  let position = computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n  let normalizedOffset = offset;\n  let space = getAvailableSpace(\n    boundaryDimensions,\n    containerOffsetWithBoundary,\n    childOffset,\n    margins,\n    padding + offset,\n    placementInfo\n  );\n\n  // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip\n  if (flip && scrollSize[size] > space) {\n    let flippedPlacementInfo = parsePlacement(`${FLIPPED_DIRECTION[placement]} ${crossPlacement}` as Placement);\n    let flippedPosition = computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n    let flippedSpace = getAvailableSpace(\n      boundaryDimensions,\n      containerOffsetWithBoundary,\n      childOffset,\n      margins,\n      padding + offset,\n      flippedPlacementInfo\n    );\n\n    // If the available space for the flipped position is greater than the original available space, flip.\n    if (flippedSpace > space) {\n      placementInfo = flippedPlacementInfo;\n      position = flippedPosition;\n      normalizedOffset = offset;\n    }\n  }\n\n  // Determine the direction the height of the overlay can grow so that we can choose how to calculate the max height\n  let heightGrowthDirection: HeightGrowthDirection = 'bottom';\n  if (placementInfo.axis === 'top') {\n    if (placementInfo.placement === 'top') {\n      heightGrowthDirection = 'top';\n    } else if (placementInfo.placement === 'bottom') {\n      heightGrowthDirection = 'bottom';\n    }\n  } else if (placementInfo.crossAxis === 'top') {\n    if (placementInfo.crossPlacement === 'top') {\n      heightGrowthDirection = 'bottom';\n    } else if (placementInfo.crossPlacement === 'bottom') {\n      heightGrowthDirection = 'top';\n    }\n  }\n\n  let delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);\n  position[crossAxis] += delta;\n\n  let maxHeight = getMaxHeight(\n    position,\n    boundaryDimensions,\n    containerOffsetWithBoundary,\n    isContainerPositioned,\n    margins,\n    padding,\n    overlaySize.height,\n    heightGrowthDirection\n  );\n\n  if (userSetMaxHeight && userSetMaxHeight < maxHeight) {\n    maxHeight = userSetMaxHeight;\n  }\n\n  overlaySize.height = Math.min(overlaySize.height, maxHeight);\n\n  position = computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);\n  delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding, containerOffsetWithBoundary);\n  position[crossAxis] += delta;\n\n  let arrowPosition: Position = {};\n\n  // All values are transformed so that 0 is at the top/left of the overlay depending on the orientation\n  // Prefer the arrow being in the center of the trigger/overlay anchor element\n  let preferredArrowPosition = childOffset[crossAxis] + .5 * childOffset[crossSize] - overlaySize[crossAxis];\n\n  // Min/Max position limits for the arrow with respect to the overlay\n  const arrowMinPosition = arrowSize / 2 + arrowBoundaryOffset;\n  const arrowMaxPosition = overlaySize[crossSize] - (arrowSize / 2) - arrowBoundaryOffset;\n\n  // Min/Max position limits for the arrow with respect to the trigger/overlay anchor element\n  const arrowOverlappingChildMinEdge = childOffset[crossAxis] - overlaySize[crossAxis] + (arrowSize / 2);\n  const arrowOverlappingChildMaxEdge = childOffset[crossAxis] + childOffset[crossSize] - overlaySize[crossAxis] - (arrowSize / 2);\n\n  // Clamp the arrow positioning so that it always is within the bounds of the anchor and the overlay\n  const arrowPositionOverlappingChild = clamp(preferredArrowPosition, arrowOverlappingChildMinEdge, arrowOverlappingChildMaxEdge);\n  arrowPosition[crossAxis] = clamp(arrowPositionOverlappingChild, arrowMinPosition, arrowMaxPosition);\n\n  return {\n    position,\n    maxHeight: maxHeight,\n    arrowOffsetLeft: arrowPosition.left,\n    arrowOffsetTop: arrowPosition.top,\n    placement: placementInfo.placement\n  };\n}\n\n/**\n * Determines where to place the overlay with regards to the target and the position of an optional indicator.\n */\nexport function calculatePosition(opts: PositionOpts): PositionResult {\n  let {\n    placement,\n    targetNode,\n    overlayNode,\n    scrollNode,\n    padding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    maxHeight,\n    arrowSize = 0,\n    arrowBoundaryOffset = 0\n  } = opts;\n\n  let container = overlayNode instanceof HTMLElement ? getContainingBlock(overlayNode) : document.documentElement;\n  let isViewportContainer = container === document.documentElement;\n  const containerPositionStyle = window.getComputedStyle(container).position;\n  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';\n  let childOffset: Offset = isViewportContainer ? getOffset(targetNode) : getPosition(targetNode, container);\n\n  if (!isViewportContainer) {\n    let {marginTop, marginLeft} = window.getComputedStyle(targetNode);\n    childOffset.top += parseInt(marginTop, 10) || 0;\n    childOffset.left += parseInt(marginLeft, 10) || 0;\n  }\n\n  let overlaySize: Offset = getOffset(overlayNode);\n  let margins = getMargins(overlayNode);\n  overlaySize.width += margins.left + margins.right;\n  overlaySize.height += margins.top + margins.bottom;\n\n  let scrollSize = getScroll(scrollNode);\n  let boundaryDimensions = getContainerDimensions(boundaryElement);\n  let containerDimensions = getContainerDimensions(container);\n  // If the container is the HTML element wrapping the body element, the retrieved scrollTop/scrollLeft will be equal to the\n  // body element's scroll. Set the container's scroll values to 0 since the overlay's edge position value in getDelta don't then need to be further offset\n  // by the container scroll since they are essentially the same containing element and thus in the same coordinate system\n  let containerOffsetWithBoundary: Offset = boundaryElement.tagName === 'BODY' ? getOffset(container) : getPosition(container, boundaryElement);\n  if (container.tagName === 'HTML' && boundaryElement.tagName === 'BODY') {\n    containerDimensions.scroll.top = 0;\n    containerDimensions.scroll.left = 0;\n  }\n\n  return calculatePositionInternal(\n    placement,\n    childOffset,\n    overlaySize,\n    scrollSize,\n    margins,\n    padding,\n    shouldFlip,\n    boundaryDimensions,\n    containerDimensions,\n    containerOffsetWithBoundary,\n    offset,\n    crossOffset,\n    isContainerPositioned,\n    maxHeight,\n    arrowSize,\n    arrowBoundaryOffset\n  );\n}\n\nfunction getOffset(node: Element): Offset {\n  let {top, left, width, height} = node.getBoundingClientRect();\n  let {scrollTop, scrollLeft, clientTop, clientLeft} = document.documentElement;\n  return {\n    top: top + scrollTop - clientTop,\n    left: left + scrollLeft - clientLeft,\n    width,\n    height\n  };\n}\n\nfunction getPosition(node: Element, parent: Element): Offset {\n  let style = window.getComputedStyle(node);\n  let offset: Offset;\n  if (style.position === 'fixed') {\n    let {top, left, width, height} = node.getBoundingClientRect();\n    offset = {top, left, width, height};\n  } else {\n    offset = getOffset(node);\n    let parentOffset = getOffset(parent);\n    let parentStyle = window.getComputedStyle(parent);\n    parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;\n    parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;\n    offset.top -= parentOffset.top;\n    offset.left -= parentOffset.left;\n  }\n\n  offset.top -= parseInt(style.marginTop, 10) || 0;\n  offset.left -= parseInt(style.marginLeft, 10) || 0;\n  return offset;\n}\n\n// Returns the containing block of an element, which is the element that\n// this element will be positioned relative to.\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block\nfunction getContainingBlock(node: HTMLElement): Element {\n  // The offsetParent of an element in most cases equals the containing block.\n  // https://w3c.github.io/csswg-drafts/cssom-view/#dom-htmlelement-offsetparent\n  let offsetParent = node.offsetParent;\n\n  // The offsetParent algorithm terminates at the document body,\n  // even if the body is not a containing block. Double check that\n  // and use the documentElement if so.\n  if (\n    offsetParent &&\n    offsetParent === document.body &&\n    window.getComputedStyle(offsetParent).position === 'static' &&\n    !isContainingBlock(offsetParent)\n  ) {\n    offsetParent = document.documentElement;\n  }\n\n  // TODO(later): handle table elements?\n\n  // The offsetParent can be null if the element has position: fixed, or a few other cases.\n  // We have to walk up the tree manually in this case because fixed positioned elements\n  // are still positioned relative to their containing block, which is not always the viewport.\n  if (offsetParent == null) {\n    offsetParent = node.parentElement;\n    while (offsetParent && !isContainingBlock(offsetParent)) {\n      offsetParent = offsetParent.parentElement;\n    }\n  }\n\n  // Fall back to the viewport.\n  return offsetParent || document.documentElement;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\nfunction isContainingBlock(node: Element): boolean {\n  let style = window.getComputedStyle(node);\n  return (\n    style.transform !== 'none' ||\n    /transform|perspective/.test(style.willChange) ||\n    style.filter !== 'none' ||\n    style.contain === 'paint' ||\n    // @ts-ignore\n    ('backdropFilter' in style && style.backdropFilter !== 'none') ||\n    // @ts-ignore\n    ('WebkitBackdropFilter' in style && style.WebkitBackdropFilter !== 'none')\n  );\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RefObject, useEffect} from 'react';\n\n// This behavior moved from useOverlayTrigger to useOverlayPosition.\n// For backward compatibility, where useOverlayTrigger handled hiding the popover on close,\n// it sets a close function here mapped from the trigger element. This way we can avoid\n// forcing users to pass an onClose function to useOverlayPosition which could be considered\n// a breaking change.\nexport const onCloseMap: WeakMap<Element, () => void> = new WeakMap();\n\ninterface CloseOnScrollOptions {\n  triggerRef: RefObject<Element>,\n  isOpen?: boolean,\n  onClose?: () => void\n}\n\n/** @private */\nexport function useCloseOnScroll(opts: CloseOnScrollOptions) {\n  let {triggerRef, isOpen, onClose} = opts;\n\n  useEffect(() => {\n    if (!isOpen || onClose === null) {\n      return;\n    }\n\n    let onScroll = (e: MouseEvent) => {\n      // Ignore if scrolling an scrollable region outside the trigger's tree.\n      let target = e.target;\n      // window is not a Node and doesn't have contain, but window contains everything\n      if (!triggerRef.current || ((target instanceof Node) && !target.contains(triggerRef.current))) {\n        return;\n      }\n\n      let onCloseHandler = onClose || onCloseMap.get(triggerRef.current);\n      if (onCloseHandler) {\n        onCloseHandler();\n      }\n    };\n\n    window.addEventListener('scroll', onScroll, true);\n    return () => {\n      window.removeEventListener('scroll', onScroll, true);\n    };\n  }, [isOpen, onClose, triggerRef]);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes} from '@react-types/shared';\nimport {isElementInChildOfActiveScope} from '@react-aria/focus';\nimport {RefObject, useEffect} from 'react';\nimport {useFocusWithin, useInteractOutside} from '@react-aria/interactions';\n\nexport interface AriaOverlayProps {\n  /** Whether the overlay is currently open. */\n  isOpen?: boolean,\n\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void,\n\n  /**\n   * Whether to close the overlay when the user interacts outside it.\n   * @default false\n   */\n  isDismissable?: boolean,\n\n  /** Whether the overlay should close when focus is lost or moves outside it. */\n  shouldCloseOnBlur?: boolean,\n\n  /**\n   * Whether pressing the escape key to close the overlay should be disabled.\n   * @default false\n   */\n  isKeyboardDismissDisabled?: boolean,\n\n  /**\n   * When user interacts with the argument element outside of the overlay ref,\n   * return true if onClose should be called.  This gives you a chance to filter\n   * out interaction with elements that should not dismiss the overlay.\n   * By default, onClose will always be called on interaction outside the overlay ref.\n   */\n  shouldCloseOnInteractOutside?: (element: Element) => boolean\n}\n\nexport interface OverlayAria {\n  /** Props to apply to the overlay container element. */\n  overlayProps: DOMAttributes,\n  /** Props to apply to the underlay element, if any. */\n  underlayProps: DOMAttributes\n}\n\nconst visibleOverlays: RefObject<Element>[] = [];\n\n/**\n * Provides the behavior for overlays such as dialogs, popovers, and menus.\n * Hides the overlay when the user interacts outside it, when the Escape key is pressed,\n * or optionally, on blur. Only the top-most overlay will close at once.\n */\nexport function useOverlay(props: AriaOverlayProps, ref: RefObject<Element>): OverlayAria {\n  let {\n    onClose,\n    shouldCloseOnBlur,\n    isOpen,\n    isDismissable = false,\n    isKeyboardDismissDisabled = false,\n    shouldCloseOnInteractOutside\n  } = props;\n\n  // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.\n  useEffect(() => {\n    if (isOpen) {\n      visibleOverlays.push(ref);\n    }\n\n    return () => {\n      let index = visibleOverlays.indexOf(ref);\n      if (index >= 0) {\n        visibleOverlays.splice(index, 1);\n      }\n    };\n  }, [isOpen, ref]);\n\n  // Only hide the overlay when it is the topmost visible overlay in the stack\n  let onHide = () => {\n    if (visibleOverlays[visibleOverlays.length - 1] === ref && onClose) {\n      onClose();\n    }\n  };\n\n  let onInteractOutsideStart = (e: PointerEvent) => {\n    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target as Element)) {\n      if (visibleOverlays[visibleOverlays.length - 1] === ref) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    }\n  };\n\n  let onInteractOutside = (e: PointerEvent) => {\n    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target as Element)) {\n      if (visibleOverlays[visibleOverlays.length - 1] === ref) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n      onHide();\n    }\n  };\n\n  // Handle the escape key\n  let onKeyDown = (e) => {\n    if (e.key === 'Escape' && !isKeyboardDismissDisabled) {\n      e.stopPropagation();\n      e.preventDefault();\n      onHide();\n    }\n  };\n\n  // Handle clicking outside the overlay to close it\n  useInteractOutside({ref, onInteractOutside: isDismissable && isOpen ? onInteractOutside : null, onInteractOutsideStart});\n\n  let {focusWithinProps} = useFocusWithin({\n    isDisabled: !shouldCloseOnBlur,\n    onBlurWithin: (e) => {\n      // Do not close if relatedTarget is null, which means focus is lost to the body.\n      // That can happen when switching tabs, or due to a VoiceOver/Chrome bug with Control+Option+Arrow navigation.\n      // Clicking on the body to close the overlay should already be handled by useInteractOutside.\n      // https://github.com/adobe/react-spectrum/issues/4130\n      // https://github.com/adobe/react-spectrum/issues/4922\n      //\n      // If focus is moving into a child focus scope (e.g. menu inside a dialog),\n      // do not close the outer overlay. At this point, the active scope should\n      // still be the outer overlay, since blur events run before focus.\n      if (!e.relatedTarget || isElementInChildOfActiveScope(e.relatedTarget)) {\n        return;\n      }\n\n      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.relatedTarget as Element)) {\n        onClose();\n      }\n    }\n  });\n\n  let onPointerDownUnderlay = e => {\n    // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846\n    if (e.target === e.currentTarget) {\n      e.preventDefault();\n    }\n  };\n\n  return {\n    overlayProps: {\n      onKeyDown,\n      ...focusWithinProps\n    },\n    underlayProps: {\n      onPointerDown: onPointerDownUnderlay\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {DOMProps} from '@react-types/shared';\nimport {onCloseMap} from './useCloseOnScroll';\nimport {OverlayTriggerState} from '@react-stately/overlays';\nimport {RefObject, useEffect} from 'react';\nimport {useId} from '@react-aria/utils';\n\nexport interface OverlayTriggerProps {\n  /** Type of overlay that is opened by the trigger. */\n  type: 'dialog' | 'menu' | 'listbox' | 'tree' | 'grid'\n}\n\nexport interface OverlayTriggerAria {\n  /** Props for the trigger element. */\n  triggerProps: AriaButtonProps,\n\n  /** Props for the overlay container element. */\n  overlayProps: DOMProps\n}\n\n/**\n * Handles the behavior and accessibility for an overlay trigger, e.g. a button\n * that opens a popover, menu, or other overlay that is positioned relative to the trigger.\n */\nexport function useOverlayTrigger(props: OverlayTriggerProps, state: OverlayTriggerState, ref?: RefObject<Element>): OverlayTriggerAria {\n  let {type} = props;\n  let {isOpen} = state;\n\n  // Backward compatibility. Share state close function with useOverlayPosition so it can close on scroll\n  // without forcing users to pass onClose.\n  useEffect(() => {\n    if (ref && ref.current) {\n      onCloseMap.set(ref.current, state.close);\n    }\n  });\n\n  // Aria 1.1 supports multiple values for aria-haspopup other than just menus.\n  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup\n  // However, we only add it for menus for now because screen readers often\n  // announce it as a menu even for other values.\n  let ariaHasPopup = undefined;\n  if (type === 'menu') {\n    ariaHasPopup = true;\n  } else if (type === 'listbox') {\n    ariaHasPopup = 'listbox';\n  }\n\n  let overlayId = useId();\n  return {\n    triggerProps: {\n      'aria-haspopup': ariaHasPopup,\n      'aria-expanded': isOpen,\n      'aria-controls': isOpen ? overlayId : null,\n      onPress: state.toggle\n    },\n    overlayProps: {\n      id: overlayId\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, getScrollParent, isIOS, useLayoutEffect} from '@react-aria/utils';\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean\n}\n\n// @ts-ignore\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}) {\n  let {isDisabled} = options;\n\n  useLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  return chain(\n    setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n    setStyle(document.documentElement, 'overflow', 'hidden')\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let restoreScrollableStyles;\n  let onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(e.target as Element, true);\n    if (scrollable === document.documentElement && scrollable === document.body) {\n      return;\n    }\n\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead.\n    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === 'auto') {\n      restoreScrollableStyles = setStyle(scrollable, 'overscrollBehavior', 'contain');\n    }\n  };\n\n  let onTouchMove = (e: TouchEvent) => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) {\n      e.preventDefault();\n    }\n  };\n\n  let onTouchEnd = (e: TouchEvent) => {\n    let target = e.target as HTMLElement;\n\n    // Apply this change if we're not already focused on the target element\n    if (willOpenKeyboard(target) && target !== document.activeElement) {\n      e.preventDefault();\n      setupStyles();\n\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n      // be done before the \"focus\" event, so we have to focus the element ourselves.\n      target.style.transform = 'translateY(-2000px)';\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n      });\n    }\n\n    if (restoreScrollableStyles) {\n      restoreScrollableStyles();\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    let target = e.target as HTMLElement;\n    if (willOpenKeyboard(target)) {\n      setupStyles();\n\n      // Transform also needs to be applied in the focus event in cases where focus moves\n      // other than tapping on an input directly, e.g. the next/previous buttons in the\n      // software keyboard. In these cases, it seems applying the transform in the focus event\n      // is good enough, whereas when tapping an input, it must be done before the focus event. 🤷‍♂️\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener('resize', () => scrollIntoView(target), {once: true});\n          }\n        }\n      });\n    }\n  };\n\n  let restoreStyles = null;\n  let setupStyles = () => {\n    if (restoreStyles) {\n      return;\n    }\n\n    let onWindowScroll = () => {\n      // Last resort. If the window scrolled, scroll it back to the top.\n      // It should always be at the top because the body will have a negative margin (see below).\n      window.scrollTo(0, 0);\n    };\n\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n\n    restoreStyles = chain(\n      addEvent(window, 'scroll', onWindowScroll),\n      setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n      setStyle(document.documentElement, 'overflow', 'hidden'),\n      setStyle(document.body, 'marginTop', `-${scrollY}px`),\n      () => {\n        window.scrollTo(scrollX, scrollY);\n      }\n    );\n\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n  };\n\n  let removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, {passive: false, capture: true}),\n    addEvent(document, 'touchmove', onTouchMove, {passive: false, capture: true}),\n    addEvent(document, 'touchend', onTouchEnd, {passive: false, capture: true}),\n    addEvent(document, 'focus', onFocus, true)\n  );\n\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreScrollableStyles?.();\n    restoreStyles?.();\n    removeEvents();\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  let cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: EventTarget,\n  event: K,\n  handler: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  target.addEventListener(event, handler, options);\n  return () => {\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoView(target: Element) {\n  let root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = target.getBoundingClientRect().top;\n      if (targetTop > scrollableTop + target.clientHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n\n    target = scrollable.parentElement;\n  }\n}\n\nfunction willOpenKeyboard(target: Element) {\n  return (\n    (target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type)) ||\n    target instanceof HTMLTextAreaElement ||\n    (target instanceof HTMLElement && target.isContentEditable)\n  );\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes} from '@react-types/shared';\nimport React, {AriaAttributes, ReactNode, useContext, useEffect, useMemo, useState} from 'react';\nimport ReactDOM from 'react-dom';\nimport {useIsSSR} from '@react-aria/ssr';\n\nexport interface ModalProviderProps extends DOMAttributes {\n  children: ReactNode\n}\n\ninterface ModalContext {\n  parent: ModalContext | null,\n  modalCount: number,\n  addModal: () => void,\n  removeModal: () => void\n}\n\nconst Context = React.createContext<ModalContext | null>(null);\n\n/**\n * Each ModalProvider tracks how many modals are open in its subtree. On mount, the modals\n * trigger `addModal` to increment the count, and trigger `removeModal` on unmount to decrement it.\n * This is done recursively so that all parent providers are incremented and decremented.\n * If the modal count is greater than zero, we add `aria-hidden` to this provider to hide its\n * subtree from screen readers. This is done using React context in order to account for things\n * like portals, which can cause the React tree and the DOM tree to differ significantly in structure.\n */\nexport function ModalProvider(props: ModalProviderProps) {\n  let {children} = props;\n  let parent = useContext(Context);\n  let [modalCount, setModalCount] = useState(0);\n  let context = useMemo(() => ({\n    parent,\n    modalCount,\n    addModal() {\n      setModalCount(count => count + 1);\n      if (parent) {\n        parent.addModal();\n      }\n    },\n    removeModal() {\n      setModalCount(count => count - 1);\n      if (parent) {\n        parent.removeModal();\n      }\n    }\n  }), [parent, modalCount]);\n\n  return (\n    <Context.Provider value={context}>\n      {children}\n    </Context.Provider>\n  );\n}\n\nexport interface ModalProviderAria {\n  /**\n   * Props to be spread on the container element.\n   */\n  modalProviderProps: AriaAttributes\n}\n\n/**\n * Used to determine if the tree should be aria-hidden based on how many\n * modals are open.\n */\nexport function useModalProvider(): ModalProviderAria {\n  let context = useContext(Context);\n  return {\n    modalProviderProps: {\n      'aria-hidden': context && context.modalCount > 0 ? true : null\n    }\n  };\n}\n\n/**\n * Creates a root node that will be aria-hidden if there are other modals open.\n */\nfunction OverlayContainerDOM(props: ModalProviderProps) {\n  let {modalProviderProps} = useModalProvider();\n  return <div data-overlay-container {...props} {...modalProviderProps} />;\n}\n\n/**\n * An OverlayProvider acts as a container for the top-level application.\n * Any application that uses modal dialogs or other overlays should\n * be wrapped in a `<OverlayProvider>`. This is used to ensure that\n * the main content of the application is hidden from screen readers\n * if a modal or other overlay is opened. Only the top-most modal or\n * overlay should be accessible at once.\n */\nexport function OverlayProvider(props: ModalProviderProps) {\n  return (\n    <ModalProvider>\n      <OverlayContainerDOM {...props} />\n    </ModalProvider>\n  );\n}\n\nexport interface OverlayContainerProps extends ModalProviderProps {\n  /**\n   * The container element in which the overlay portal will be placed.\n   * @default document.body\n   */\n  portalContainer?: Element\n}\n\n/**\n * A container for overlays like modals and popovers. Renders the overlay\n * into a Portal which is placed at the end of the document body.\n * Also ensures that the overlay is hidden from screen readers if a\n * nested modal is opened. Only the top-most modal or overlay should\n * be accessible at once.\n */\nexport function OverlayContainer(props: OverlayContainerProps): React.ReactPortal {\n  let isSSR = useIsSSR();\n  let {portalContainer = isSSR ? null : document.body, ...rest} = props;\n\n  React.useEffect(() => {\n    if (portalContainer?.closest('[data-overlay-container]')) {\n      throw new Error('An OverlayContainer must not be inside another container. Please change the portalContainer prop.');\n    }\n  }, [portalContainer]);\n\n  if (!portalContainer) {\n    return null;\n  }\n\n  let contents = <OverlayProvider {...rest} />;\n  return ReactDOM.createPortal(contents, portalContainer);\n}\n\ninterface ModalAriaProps extends DOMAttributes {\n  /** Data attribute marks the dom node as a modal for the aria-modal-polyfill. */\n  'data-ismodal': boolean\n}\n\nexport interface AriaModalOptions {\n  isDisabled?: boolean\n}\n\nexport interface ModalAria {\n  /** Props for the modal content element. */\n  modalProps: ModalAriaProps\n}\n\n/**\n * Hides content outside the current `<OverlayContainer>` from screen readers\n * on mount and restores it on unmount. Typically used by modal dialogs and\n * other types of overlays to ensure that only the top-most modal is\n * accessible at once.\n */\nexport function useModal(options?: AriaModalOptions): ModalAria {\n  // Add aria-hidden to all parent providers on mount, and restore on unmount.\n  let context = useContext(Context);\n  if (!context) {\n    throw new Error('Modal is not contained within a provider');\n  }\n\n  useEffect(() => {\n    if (options?.isDisabled || !context || !context.parent) {\n      return;\n    }\n\n    // The immediate context is from the provider containing this modal, so we only\n    // want to trigger aria-hidden on its parents not on the modal provider itself.\n    context.parent.addModal();\n    return () => {\n      if (context && context.parent) {\n        context.parent.removeModal();\n      }\n    };\n  }, [context, context.parent, options?.isDisabled]);\n\n  return {\n    modalProps: {\n      'data-ismodal': !options?.isDisabled\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, DOMProps} from '@react-types/shared';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport React from 'react';\nimport {useLabels} from '@react-aria/utils';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {VisuallyHidden} from '@react-aria/visually-hidden';\n\nexport interface DismissButtonProps extends AriaLabelingProps, DOMProps {\n  /** Called when the dismiss button is activated. */\n  onDismiss?: () => void\n}\n\n/**\n * A visually hidden button that can be used to allow screen reader\n * users to dismiss a modal or popup when there is no visual\n * affordance to do so.\n */\nexport function DismissButton(props: DismissButtonProps) {\n  let {onDismiss, ...otherProps} = props;\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/overlays');\n\n  let labels = useLabels(otherProps, stringFormatter.format('dismiss'));\n\n  let onClick = () => {\n    if (onDismiss) {\n      onDismiss();\n    }\n  };\n\n  return (\n    <VisuallyHidden>\n      <button\n        {...labels}\n        tabIndex={-1}\n        onClick={onClick}\n        style={{width: 1, height: 1}} />\n    </VisuallyHidden>\n  );\n}\n","const _temp0 = require(\"../intl/ar-AE.json\");\nconst _temp1 = require(\"../intl/bg-BG.json\");\nconst _temp2 = require(\"../intl/cs-CZ.json\");\nconst _temp3 = require(\"../intl/da-DK.json\");\nconst _temp4 = require(\"../intl/de-DE.json\");\nconst _temp5 = require(\"../intl/el-GR.json\");\nconst _temp6 = require(\"../intl/en-US.json\");\nconst _temp7 = require(\"../intl/es-ES.json\");\nconst _temp8 = require(\"../intl/et-EE.json\");\nconst _temp9 = require(\"../intl/fi-FI.json\");\nconst _temp10 = require(\"../intl/fr-FR.json\");\nconst _temp11 = require(\"../intl/he-IL.json\");\nconst _temp12 = require(\"../intl/hr-HR.json\");\nconst _temp13 = require(\"../intl/hu-HU.json\");\nconst _temp14 = require(\"../intl/it-IT.json\");\nconst _temp15 = require(\"../intl/ja-JP.json\");\nconst _temp16 = require(\"../intl/ko-KR.json\");\nconst _temp17 = require(\"../intl/lt-LT.json\");\nconst _temp18 = require(\"../intl/lv-LV.json\");\nconst _temp19 = require(\"../intl/nb-NO.json\");\nconst _temp20 = require(\"../intl/nl-NL.json\");\nconst _temp21 = require(\"../intl/pl-PL.json\");\nconst _temp22 = require(\"../intl/pt-BR.json\");\nconst _temp23 = require(\"../intl/pt-PT.json\");\nconst _temp24 = require(\"../intl/ro-RO.json\");\nconst _temp25 = require(\"../intl/ru-RU.json\");\nconst _temp26 = require(\"../intl/sk-SK.json\");\nconst _temp27 = require(\"../intl/sl-SI.json\");\nconst _temp28 = require(\"../intl/sr-SP.json\");\nconst _temp29 = require(\"../intl/sv-SE.json\");\nconst _temp30 = require(\"../intl/tr-TR.json\");\nconst _temp31 = require(\"../intl/uk-UA.json\");\nconst _temp32 = require(\"../intl/zh-CN.json\");\nconst _temp33 = require(\"../intl/zh-TW.json\");\nmodule.exports = {\n  \"ar-AE\": _temp0,\n  \"bg-BG\": _temp1,\n  \"cs-CZ\": _temp2,\n  \"da-DK\": _temp3,\n  \"de-DE\": _temp4,\n  \"el-GR\": _temp5,\n  \"en-US\": _temp6,\n  \"es-ES\": _temp7,\n  \"et-EE\": _temp8,\n  \"fi-FI\": _temp9,\n  \"fr-FR\": _temp10,\n  \"he-IL\": _temp11,\n  \"hr-HR\": _temp12,\n  \"hu-HU\": _temp13,\n  \"it-IT\": _temp14,\n  \"ja-JP\": _temp15,\n  \"ko-KR\": _temp16,\n  \"lt-LT\": _temp17,\n  \"lv-LV\": _temp18,\n  \"nb-NO\": _temp19,\n  \"nl-NL\": _temp20,\n  \"pl-PL\": _temp21,\n  \"pt-BR\": _temp22,\n  \"pt-PT\": _temp23,\n  \"ro-RO\": _temp24,\n  \"ru-RU\": _temp25,\n  \"sk-SK\": _temp26,\n  \"sl-SI\": _temp27,\n  \"sr-SP\": _temp28,\n  \"sv-SE\": _temp29,\n  \"tr-TR\": _temp30,\n  \"uk-UA\": _temp31,\n  \"zh-CN\": _temp32,\n  \"zh-TW\": _temp33\n}","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Keeps a ref count of all hidden elements. Added to when hiding an element, and\n// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.\nlet refCountMap = new WeakMap<Element, number>();\nlet observerStack = [];\n\n/**\n * Hides all elements in the DOM outside the given targets from screen readers using aria-hidden,\n * and returns a function to revert these changes. In addition, changes to the DOM are watched\n * and new elements outside the targets are automatically hidden.\n * @param targets - The elements that should remain visible.\n * @param root - Nothing will be hidden above this element.\n * @returns - A function to restore all hidden elements.\n */\nexport function ariaHideOutside(targets: Element[], root = document.body) {\n  let visibleNodes = new Set<Element>(targets);\n  let hiddenNodes = new Set<Element>();\n\n  let walk = (root: Element) => {\n    // Keep live announcer and top layer elements (e.g. toasts) visible.\n    for (let element of root.querySelectorAll('[data-live-announcer], [data-react-aria-top-layer]')) {\n      visibleNodes.add(element);\n    }\n\n    let acceptNode = (node: Element) => {\n      // Skip this node and its children if it is one of the target nodes, or a live announcer.\n      // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is\n      // made for elements with role=\"row\" since VoiceOver on iOS has issues hiding elements with role=\"row\".\n      // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).\n      if (\n        visibleNodes.has(node) ||\n        (hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute('role') !== 'row')\n      ) {\n        return NodeFilter.FILTER_REJECT;\n      }\n\n      // Skip this node but continue to children if one of the targets is inside the node.\n      for (let target of visibleNodes) {\n        if (node.contains(target)) {\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n\n      return NodeFilter.FILTER_ACCEPT;\n    };\n\n    let walker = document.createTreeWalker(\n      root,\n      NodeFilter.SHOW_ELEMENT,\n      {acceptNode}\n    );\n\n    // TreeWalker does not include the root.\n    let acceptRoot = acceptNode(root);\n    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {\n      hide(root);\n    }\n\n    if (acceptRoot !== NodeFilter.FILTER_REJECT) {\n      let node = walker.nextNode() as Element;\n      while (node != null) {\n        hide(node);\n        node = walker.nextNode() as Element;\n      }\n    }\n  };\n\n  let hide = (node: Element) => {\n    let refCount = refCountMap.get(node) ?? 0;\n\n    // If already aria-hidden, and the ref count is zero, then this element\n    // was already hidden and there's nothing for us to do.\n    if (node.getAttribute('aria-hidden') === 'true' && refCount === 0) {\n      return;\n    }\n\n    if (refCount === 0) {\n      node.setAttribute('aria-hidden', 'true');\n    }\n\n    hiddenNodes.add(node);\n    refCountMap.set(node, refCount + 1);\n  };\n\n  // If there is already a MutationObserver listening from a previous call,\n  // disconnect it so the new on takes over.\n  if (observerStack.length) {\n    observerStack[observerStack.length - 1].disconnect();\n  }\n\n  walk(root);\n\n  let observer = new MutationObserver(changes => {\n    for (let change of changes) {\n      if (change.type !== 'childList' || change.addedNodes.length === 0) {\n        continue;\n      }\n\n      // If the parent element of the added nodes is not within one of the targets,\n      // and not already inside a hidden node, hide all of the new children.\n      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {\n        for (let node of change.removedNodes) {\n          if (node instanceof Element) {\n            visibleNodes.delete(node);\n            hiddenNodes.delete(node);\n          }\n        }\n\n        for (let node of change.addedNodes) {\n          if (\n            (node instanceof HTMLElement || node instanceof SVGElement) &&\n            (node.dataset.liveAnnouncer === 'true' || node.dataset.reactAriaTopLayer === 'true')\n          ) {\n            visibleNodes.add(node);\n          } else if (node instanceof Element) {\n            walk(node);\n          }\n        }\n      }\n    }\n  });\n\n  observer.observe(root, {childList: true, subtree: true});\n\n  let observerWrapper = {\n    observe() {\n      observer.observe(root, {childList: true, subtree: true});\n    },\n    disconnect() {\n      observer.disconnect();\n    }\n  };\n\n  observerStack.push(observerWrapper);\n\n  return () => {\n    observer.disconnect();\n\n    for (let node of hiddenNodes) {\n      let count = refCountMap.get(node);\n      if (count === 1) {\n        node.removeAttribute('aria-hidden');\n        refCountMap.delete(node);\n      } else {\n        refCountMap.set(node, count - 1);\n      }\n    }\n\n    // Remove this observer from the stack, and start the previous one.\n    if (observerWrapper === observerStack[observerStack.length - 1]) {\n      observerStack.pop();\n      if (observerStack.length) {\n        observerStack[observerStack.length - 1].observe();\n      }\n    } else {\n      observerStack.splice(observerStack.indexOf(observerWrapper), 1);\n    }\n  };\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ariaHideOutside} from './ariaHideOutside';\nimport {AriaPositionProps, useOverlayPosition} from './useOverlayPosition';\nimport {DOMAttributes} from '@react-types/shared';\nimport {mergeProps, useLayoutEffect} from '@react-aria/utils';\nimport {OverlayTriggerState} from '@react-stately/overlays';\nimport {PlacementAxis} from '@react-types/overlays';\nimport {RefObject} from 'react';\nimport {useOverlay} from './useOverlay';\nimport {usePreventScroll} from './usePreventScroll';\n\nexport interface AriaPopoverProps extends Omit<AriaPositionProps, 'isOpen' | 'onClose' | 'targetRef' | 'overlayRef'> {\n  /**\n   * The ref for the element which the popover positions itself with respect to.\n   */\n  triggerRef: RefObject<Element>,\n  /**\n   * The ref for the popover element.\n   */\n  popoverRef: RefObject<Element>,\n  /**\n   * Whether the popover is non-modal, i.e. elements outside the popover may be\n   * interacted with by assistive technologies.\n   *\n   * Most popovers should not use this option as it may negatively impact the screen\n   * reader experience. Only use with components such as combobox, which are designed\n   * to handle this situation carefully.\n   */\n  isNonModal?: boolean,\n  /**\n   * Whether pressing the escape key to close the popover should be disabled.\n   *\n   * Most popovers should not use this option. When set to true, an alternative\n   * way to close the popover with a keyboard must be provided.\n   *\n   * @default false\n   */\n  isKeyboardDismissDisabled?: boolean,\n  /**\n   * When user interacts with the argument element outside of the popover ref,\n   * return true if onClose should be called. This gives you a chance to filter\n   * out interaction with elements that should not dismiss the popover.\n   * By default, onClose will always be called on interaction outside the popover ref.\n   */\n  shouldCloseOnInteractOutside?: (element: Element) => boolean\n}\n\nexport interface PopoverAria {\n  /** Props for the popover element. */\n  popoverProps: DOMAttributes,\n  /** Props for the popover tip arrow if any. */\n  arrowProps: DOMAttributes,\n  /** Props to apply to the underlay element, if any. */\n  underlayProps: DOMAttributes,\n  /** Placement of the popover with respect to the trigger. */\n  placement: PlacementAxis\n}\n\n/**\n * Provides the behavior and accessibility implementation for a popover component.\n * A popover is an overlay element positioned relative to a trigger.\n */\nexport function usePopover(props: AriaPopoverProps, state: OverlayTriggerState): PopoverAria {\n  let {\n    triggerRef,\n    popoverRef,\n    isNonModal,\n    isKeyboardDismissDisabled,\n    shouldCloseOnInteractOutside,\n    ...otherProps\n  } = props;\n\n  let {overlayProps, underlayProps} = useOverlay(\n    {\n      isOpen: state.isOpen,\n      onClose: state.close,\n      shouldCloseOnBlur: true,\n      isDismissable: !isNonModal,\n      isKeyboardDismissDisabled,\n      shouldCloseOnInteractOutside\n    },\n    popoverRef\n  );\n\n  let {overlayProps: positionProps, arrowProps, placement} = useOverlayPosition({\n    ...otherProps,\n    targetRef: triggerRef,\n    overlayRef: popoverRef,\n    isOpen: state.isOpen,\n    onClose: isNonModal ? state.close : null\n  });\n\n  usePreventScroll({\n    isDisabled: isNonModal || !state.isOpen\n  });\n\n  useLayoutEffect(() => {\n    if (state.isOpen && !isNonModal && popoverRef.current) {\n      return ariaHideOutside([popoverRef.current]);\n    }\n  }, [isNonModal, state.isOpen, popoverRef]);\n\n  return {\n    popoverProps: mergeProps(overlayProps, positionProps),\n    arrowProps,\n    underlayProps,\n    placement\n  };\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ariaHideOutside} from './ariaHideOutside';\nimport {DOMAttributes} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {OverlayTriggerState} from '@react-stately/overlays';\nimport {RefObject, useEffect} from 'react';\nimport {useOverlay} from './useOverlay';\nimport {useOverlayFocusContain} from './Overlay';\nimport {usePreventScroll} from './usePreventScroll';\n\nexport interface AriaModalOverlayProps {\n  /**\n   * Whether to close the modal when the user interacts outside it.\n   * @default false\n   */\n  isDismissable?: boolean,\n  /**\n   * Whether pressing the escape key to close the modal should be disabled.\n   * @default false\n   */\n  isKeyboardDismissDisabled?: boolean\n}\n\nexport interface ModalOverlayAria {\n  /** Props for the modal element. */\n  modalProps: DOMAttributes,\n  /** Props for the underlay element. */\n  underlayProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a modal component.\n * A modal is an overlay element which blocks interaction with elements outside it.\n */\nexport function useModalOverlay(props: AriaModalOverlayProps, state: OverlayTriggerState, ref: RefObject<HTMLElement>): ModalOverlayAria {\n  let {overlayProps, underlayProps} = useOverlay({\n    ...props,\n    isOpen: state.isOpen,\n    onClose: state.close\n  }, ref);\n\n  usePreventScroll({\n    isDisabled: !state.isOpen\n  });\n\n  useOverlayFocusContain();\n\n  useEffect(() => {\n    if (state.isOpen) {\n      return ariaHideOutside([ref.current]);\n    }\n  }, [state.isOpen, ref]);\n\n  return {\n    modalProps: mergeProps(overlayProps),\n    underlayProps\n  };\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ClearPressResponder} from '@react-aria/interactions';\nimport {FocusScope} from '@react-aria/focus';\nimport React, {ReactNode, useContext, useMemo, useState} from 'react';\nimport ReactDOM from 'react-dom';\nimport {useIsSSR} from '@react-aria/ssr';\nimport {useLayoutEffect} from '@react-aria/utils';\n\nexport interface OverlayProps {\n  /**\n   * The container element in which the overlay portal will be placed.\n   * @default document.body\n   */\n  portalContainer?: Element,\n  /** The overlay to render in the portal. */\n  children: ReactNode,\n  /**\n   * Disables default focus management for the overlay, including containment and restoration.\n   * This option should be used very carefully. When focus management is disabled, you must\n   * implement focus containment and restoration to ensure the overlay is keyboard accessible.\n   */\n  disableFocusManagement?: boolean,\n  /**\n   * Whether the overlay is currently performing an exit animation. When true,\n   * focus is allowed to move outside.\n   */\n  isExiting?: boolean\n}\n\nexport const OverlayContext = React.createContext(null);\n\n/**\n * A container which renders an overlay such as a popover or modal in a portal,\n * and provides a focus scope for the child elements.\n */\nexport function Overlay(props: OverlayProps) {\n  let isSSR = useIsSSR();\n  let {portalContainer = isSSR ? null : document.body, isExiting} = props;\n  let [contain, setContain] = useState(false);\n  let contextValue = useMemo(() => ({contain, setContain}), [contain, setContain]);\n\n  if (!portalContainer) {\n    return null;\n  }\n\n  let contents = props.children;\n  if (!props.disableFocusManagement) {\n    contents = (\n      <FocusScope restoreFocus contain={contain && !isExiting}>\n        {contents}\n      </FocusScope>\n    );\n  }\n\n  contents = (\n    <OverlayContext.Provider value={contextValue}>\n      <ClearPressResponder>\n        {contents}\n      </ClearPressResponder>\n    </OverlayContext.Provider>\n  );\n\n  return ReactDOM.createPortal(contents, portalContainer);\n}\n\n/** @private */\nexport function useOverlayFocusContain() {\n  let ctx = useContext(OverlayContext);\n  let setContain = ctx?.setContain;\n  useLayoutEffect(() => {\n    setContain?.(true);\n  }, [setContain]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}