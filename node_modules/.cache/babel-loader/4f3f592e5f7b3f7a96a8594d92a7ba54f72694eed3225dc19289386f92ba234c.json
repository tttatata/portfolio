{"ast":null,"code":"import { useGlobalListeners as $fA3fN$useGlobalListeners, clamp as $fA3fN$clamp, mergeProps as $fA3fN$mergeProps, focusWithoutScrolling as $fA3fN$focusWithoutScrolling, useFormReset as $fA3fN$useFormReset } from \"@react-aria/utils\";\nimport { useRef as $fA3fN$useRef, useCallback as $fA3fN$useCallback, useEffect as $fA3fN$useEffect } from \"react\";\nimport { useMove as $fA3fN$useMove, setInteractionModality as $fA3fN$setInteractionModality, useKeyboard as $fA3fN$useKeyboard } from \"@react-aria/interactions\";\nimport { useLabel as $fA3fN$useLabel } from \"@react-aria/label\";\nimport { useLocale as $fA3fN$useLocale } from \"@react-aria/i18n\";\nimport { useFocusable as $fA3fN$useFocusable } from \"@react-aria/focus\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\nconst $aa519ee6cf463259$export$d6c8d9636a3dc49c = new WeakMap();\nfunction $aa519ee6cf463259$export$68e648cbec363a18(state, index) {\n  let data = $aa519ee6cf463259$export$d6c8d9636a3dc49c.get(state);\n  if (!data) throw new Error(\"Unknown slider state\");\n  return `${data.id}-${index}`;\n}\nfunction $bcca50147b47f54d$export$56b2c08e277f365(props, state, trackRef) {\n  let {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = (0, $fA3fN$useLabel)(props);\n  let isVertical = props.orientation === \"vertical\";\n  var _labelProps_id;\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  (0, $aa519ee6cf463259$export$d6c8d9636a3dc49c).set(state, {\n    id: (_labelProps_id = labelProps.id) !== null && _labelProps_id !== void 0 ? _labelProps_id : fieldProps.id,\n    \"aria-describedby\": props[\"aria-describedby\"],\n    \"aria-details\": props[\"aria-details\"]\n  });\n  let {\n    direction: direction\n  } = (0, $fA3fN$useLocale)();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = (0, $fA3fN$useGlobalListeners)();\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = (0, $fA3fN$useRef)(null);\n  const reverseX = direction === \"rtl\";\n  const currentPosition = (0, $fA3fN$useRef)(null);\n  const {\n    moveProps: moveProps\n  } = (0, $fA3fN$useMove)({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove(_ref) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY\n      } = _ref;\n      let {\n        height: height,\n        width: width\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = state.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) delta = -delta;\n      currentPosition.current += delta;\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = (0, $fA3fN$clamp)(currentPosition.current / size, 0, 1);\n        state.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n  let currentPointer = (0, $fA3fN$useRef)(undefined);\n  let onDownTrack = (e, id, clientX, clientY) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {\n        height: height,\n        width: width,\n        top: top,\n        left: left\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      // Find the closest thumb\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === \"rtl\" || isVertical) percent = 1 - percent;\n      let value = state.getPercentValue(percent);\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) closestThumb = split;else if (split === -1) closestThumb = state.values.length - 1;else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) closestThumb = split - 1;else closestThumb = split;\n      }\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n        addGlobalListener(window, \"mouseup\", onUpTrack, false);\n        addGlobalListener(window, \"touchend\", onUpTrack, false);\n        addGlobalListener(window, \"pointerup\", onUpTrack, false);\n      } else realTimeTrackDraggingIndex.current = null;\n    }\n  };\n  let onUpTrack = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n      removeGlobalListener(window, \"mouseup\", onUpTrack, false);\n      removeGlobalListener(window, \"touchend\", onUpTrack, false);\n      removeGlobalListener(window, \"pointerup\", onUpTrack, false);\n    }\n  };\n  if (\"htmlFor\" in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      var\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      _document_getElementById;\n      (_document_getElementById = document.getElementById((0, $aa519ee6cf463259$export$68e648cbec363a18)(state, 0))) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.focus();\n      (0, $fA3fN$setInteractionModality)(\"keyboard\");\n    };\n  }\n  return {\n    labelProps: labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: \"group\",\n      ...fieldProps\n    },\n    trackProps: (0, $fA3fN$mergeProps)({\n      onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e) {\n        if (e.pointerType === \"mouse\" && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e) {\n        onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      },\n      style: {\n        position: \"relative\",\n        touchAction: \"none\"\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => (0, $aa519ee6cf463259$export$68e648cbec363a18)(state, index)).join(\" \"),\n      \"aria-live\": \"off\"\n    }\n  };\n}\nfunction $47b897dc8cdb026b$export$8d15029008292ae(opts, state) {\n  let {\n    index = 0,\n    isRequired: isRequired,\n    validationState: validationState,\n    isInvalid: isInvalid,\n    trackRef: trackRef,\n    inputRef: inputRef,\n    orientation = state.orientation,\n    name: name\n  } = opts;\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === \"vertical\";\n  let {\n    direction: direction\n  } = (0, $fA3fN$useLocale)();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = (0, $fA3fN$useGlobalListeners)();\n  let data = (0, $aa519ee6cf463259$export$d6c8d9636a3dc49c).get(state);\n  var _opts_arialabelledby;\n  const {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = (0, $fA3fN$useLabel)({\n    ...opts,\n    id: (0, $aa519ee6cf463259$export$68e648cbec363a18)(state, index),\n    \"aria-labelledby\": `${data.id} ${(_opts_arialabelledby = opts[\"aria-labelledby\"]) !== null && _opts_arialabelledby !== void 0 ? _opts_arialabelledby : \"\"}`.trim()\n  });\n  const value = state.values[index];\n  const focusInput = (0, $fA3fN$useCallback)(() => {\n    if (inputRef.current) (0, $fA3fN$focusWithoutScrolling)(inputRef.current);\n  }, [inputRef]);\n  const isFocused = state.focusedThumb === index;\n  (0, $fA3fN$useEffect)(() => {\n    if (isFocused) focusInput();\n  }, [isFocused, focusInput]);\n  let reverseX = direction === \"rtl\";\n  let currentPosition = (0, $fA3fN$useRef)(null);\n  let {\n    keyboardProps: keyboardProps\n  } = (0, $fA3fN$useKeyboard)({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue: getThumbMaxValue,\n        getThumbMinValue: getThumbMinValue,\n        decrementThumb: decrementThumb,\n        incrementThumb: incrementThumb,\n        setThumbValue: setThumbValue,\n        setThumbDragging: setThumbDragging,\n        pageSize: pageSize\n      } = state;\n      // these are the cases that useMove or useSlider don't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n      e.preventDefault();\n      // remember to set this so that onChangeEnd is fired\n      setThumbDragging(index, true);\n      switch (e.key) {\n        case \"PageUp\":\n          incrementThumb(index, pageSize);\n          break;\n        case \"PageDown\":\n          decrementThumb(index, pageSize);\n          break;\n        case \"Home\":\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n        case \"End\":\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n      setThumbDragging(index, false);\n    }\n  });\n  let {\n    moveProps: moveProps\n  } = (0, $fA3fN$useMove)({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove(_ref2) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY,\n        pointerType: pointerType,\n        shiftKey: shiftKey\n      } = _ref2;\n      const {\n        getThumbPercent: getThumbPercent,\n        setThumbPercent: setThumbPercent,\n        decrementThumb: decrementThumb,\n        incrementThumb: incrementThumb,\n        step: step,\n        pageSize: pageSize\n      } = state;\n      let {\n        width: width,\n        height: height\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = getThumbPercent(index) * size;\n      if (pointerType === \"keyboard\") {\n        if (deltaX > 0 && reverseX || deltaX < 0 && !reverseX || deltaY > 0) decrementThumb(index, shiftKey ? pageSize : step);else incrementThumb(index, shiftKey ? pageSize : step);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) delta = -delta;\n        currentPosition.current += delta;\n        setThumbPercent(index, (0, $fA3fN$clamp)(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  });\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n  const {\n    focusableProps: focusableProps\n  } = (0, $fA3fN$useFocusable)((0, $fA3fN$mergeProps)(opts, {\n    onFocus: () => state.setFocusedThumb(index),\n    onBlur: () => state.setFocusedThumb(undefined)\n  }), inputRef);\n  let currentPointer = (0, $fA3fN$useRef)(undefined);\n  let onDown = id => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, \"mouseup\", onUp, false);\n    addGlobalListener(window, \"touchend\", onUp, false);\n    addGlobalListener(window, \"pointerup\", onUp, false);\n  };\n  let onUp = e => {\n    var _e_changedTouches;\n    var _e_pointerId;\n    let id = (_e_pointerId = e.pointerId) !== null && _e_pointerId !== void 0 ? _e_pointerId : (_e_changedTouches = e.changedTouches) === null || _e_changedTouches === void 0 ? void 0 : _e_changedTouches[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, \"mouseup\", onUp, false);\n      removeGlobalListener(window, \"touchend\", onUp, false);\n      removeGlobalListener(window, \"pointerup\", onUp, false);\n    }\n  };\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === \"rtl\") thumbPosition = 1 - thumbPosition;\n  let interactions = !isDisabled ? (0, $fA3fN$mergeProps)(keyboardProps, moveProps, {\n    onMouseDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown();\n    },\n    onPointerDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown(e.pointerId);\n    },\n    onTouchStart: e => {\n      onDown(e.changedTouches[0].identifier);\n    }\n  }) : {};\n  (0, $fA3fN$useFormReset)(inputRef, value, v => {\n    state.setThumbValue(index, v);\n  });\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: (0, $fA3fN$mergeProps)(focusableProps, fieldProps, {\n      type: \"range\",\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      name: name,\n      disabled: isDisabled,\n      \"aria-orientation\": orientation,\n      \"aria-valuetext\": state.getThumbValueLabel(index),\n      \"aria-required\": isRequired || undefined,\n      \"aria-invalid\": isInvalid || validationState === \"invalid\" || undefined,\n      \"aria-errormessage\": opts[\"aria-errormessage\"],\n      \"aria-describedby\": [data[\"aria-describedby\"], opts[\"aria-describedby\"]].filter(Boolean).join(\" \"),\n      \"aria-details\": [data[\"aria-details\"], opts[\"aria-details\"]].filter(Boolean).join(\" \"),\n      onChange: e => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: {\n      ...interactions,\n      style: {\n        position: \"absolute\",\n        [isVertical ? \"top\" : \"left\"]: `${thumbPosition * 100}%`,\n        transform: \"translate(-50%, -50%)\",\n        touchAction: \"none\"\n      }\n    },\n    labelProps: labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled: isDisabled,\n    isFocused: isFocused\n  };\n}\nexport { $bcca50147b47f54d$export$56b2c08e277f365 as useSlider, $47b897dc8cdb026b$export$8d15029008292ae as useSliderThumb };","map":{"version":3,"names":["$aa519ee6cf463259$export$d6c8d9636a3dc49c","WeakMap","$aa519ee6cf463259$export$68e648cbec363a18","state","index","data","get","Error","id","$bcca50147b47f54d$export$56b2c08e277f365","props","trackRef","labelProps","fieldProps","$fA3fN$useLabel","isVertical","orientation","_labelProps_id","set","direction","$fA3fN$useLocale","addGlobalListener","removeGlobalListener","$fA3fN$useGlobalListeners","realTimeTrackDraggingIndex","$fA3fN$useRef","reverseX","currentPosition","moveProps","$fA3fN$useMove","onMoveStart","current","onMove","_ref","deltaX","deltaY","height","width","getBoundingClientRect","size","getThumbPercent","delta","percent","$fA3fN$clamp","setThumbPercent","onMoveEnd","setThumbDragging","currentPointer","undefined","onDownTrack","e","clientX","clientY","isDisabled","values","every","_","i","isThumbDragging","top","left","trackPosition","clickPosition","offset","value","getPercentValue","closestThumb","split","findIndex","v","length","lastLeft","firstRight","Math","abs","isThumbEditable","preventDefault","setFocusedThumb","setThumbValue","window","onUpTrack","_e_changedTouches","_e_pointerId","pointerId","changedTouches","identifier","htmlFor","onClick","_document_getElementById","document","getElementById","focus","$fA3fN$setInteractionModality","groupProps","role","trackProps","$fA3fN$mergeProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","pointerType","onTouchStart","style","position","touchAction","outputProps","map","join","$47b897dc8cdb026b$export$8d15029008292ae","opts","isRequired","validationState","isInvalid","inputRef","name","_opts_arialabelledby","trim","focusInput","$fA3fN$useCallback","$fA3fN$focusWithoutScrolling","isFocused","focusedThumb","$fA3fN$useEffect","keyboardProps","$fA3fN$useKeyboard","onKeyDown","getThumbMaxValue","getThumbMinValue","decrementThumb","incrementThumb","pageSize","test","key","continuePropagation","_ref2","shiftKey","step","setThumbEditable","focusableProps","$fA3fN$useFocusable","onFocus","onBlur","onDown","onUp","thumbPosition","interactions","$fA3fN$useFormReset","inputProps","type","tabIndex","min","max","disabled","getThumbValueLabel","filter","Boolean","onChange","parseFloat","target","thumbProps","transform","isDragging"],"sources":["D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\slider\\dist\\packages\\@react-aria\\slider\\src\\index.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\slider\\dist\\packages\\@react-aria\\slider\\src\\useSlider.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\slider\\dist\\packages\\@react-aria\\slider\\src\\utils.ts","D:\\TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17\\frontend\\node_modules\\@react-aria\\slider\\dist\\packages\\@react-aria\\slider\\src\\useSliderThumb.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport {useSlider} from './useSlider';\nexport {useSliderThumb} from './useSliderThumb';\nexport type {AriaSliderProps} from '@react-types/slider';\nexport type {SliderAria} from './useSlider';\nexport type {AriaSliderThumbOptions, SliderThumbAria} from './useSliderThumb';\nexport type {AriaSliderThumbProps} from '@react-types/slider';\nexport type {Orientation} from '@react-types/shared';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSliderProps} from '@react-types/slider';\nimport {clamp, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderData} from './utils';\nimport React, {LabelHTMLAttributes, OutputHTMLAttributes, RefObject, useRef} from 'react';\nimport {setInteractionModality, useMove} from '@react-aria/interactions';\nimport {SliderState} from '@react-stately/slider';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderAria {\n  /** Props for the label element. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: DOMAttributes,\n\n  /** Props for the track element. */\n  trackProps: DOMAttributes,\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: OutputHTMLAttributes<HTMLOutputElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider<T extends number | number[]>(\n  props: AriaSliderProps<T>,\n  state: SliderState,\n  trackRef: RefObject<Element>\n): SliderAria {\n  let {labelProps, fieldProps} = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  sliderData.set(state, {\n    id: labelProps.id ?? fieldProps.id,\n    'aria-describedby': props['aria-describedby'],\n    'aria-details': props['aria-details']\n  });\n\n  let {direction} = useLocale();\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = useRef<number | null>(null);\n\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef<number>(null);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove({deltaX, deltaY}) {\n      let {height, width} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = state.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        state.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDownTrack = (e: React.UIEvent, id: number, clientX: number, clientY: number) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {height, width, top, left} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      // Find the closest thumb\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) { // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) { // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      document.getElementById(getSliderThumbId(state, 0))?.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: mergeProps({\n      onMouseDown(e: React.MouseEvent) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e: React.PointerEvent) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e: React.TouchEvent) { onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY); },\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n","import {SliderState} from '@react-stately/slider';\n\ninterface SliderData {\n  id: string,\n  'aria-describedby'?: string,\n  'aria-details'?: string\n}\n\nexport const sliderData = new WeakMap<SliderState, SliderData>();\n\nexport function getSliderThumbId(state: SliderState, index: number) {\n  let data = sliderData.get(state);\n  if (!data) {\n    throw new Error('Unknown slider state');\n  }\n\n  return `${data.id}-${index}`;\n}\n","import {AriaSliderThumbProps} from '@react-types/slider';\nimport {clamp, focusWithoutScrolling, mergeProps, useFormReset, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderData} from './utils';\nimport React, {ChangeEvent, InputHTMLAttributes, LabelHTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {SliderState} from '@react-stately/slider';\nimport {useFocusable} from '@react-aria/focus';\nimport {useKeyboard, useMove} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: DOMAttributes,\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Whether this thumb is currently being dragged. */\n  isDragging: boolean,\n  /** Whether the thumb is currently focused. */\n  isFocused: boolean,\n  /** Whether the thumb is disabled. */\n  isDisabled: boolean\n}\n\nexport interface AriaSliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackRef: RefObject<Element>,\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: AriaSliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index = 0,\n    isRequired,\n    validationState,\n    isInvalid,\n    trackRef,\n    inputRef,\n    orientation = state.orientation,\n    name\n  } = opts;\n\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === 'vertical';\n\n  let {direction} = useLocale();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let data = sliderData.get(state);\n  const {labelProps, fieldProps} = useLabel({\n    ...opts,\n    id: getSliderThumbId(state, index),\n    'aria-labelledby': `${data.id} ${opts['aria-labelledby'] ?? ''}`.trim()\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue,\n        getThumbMinValue,\n        decrementThumb,\n        incrementThumb,\n        setThumbValue,\n        setThumbDragging,\n        pageSize\n      } = state;\n      // these are the cases that useMove or useSlider don't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n      e.preventDefault();\n      // remember to set this so that onChangeEnd is fired\n      setThumbDragging(index, true);\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n      setThumbDragging(index, false);\n    }\n  });\n\n  let {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({deltaX, deltaY, pointerType, shiftKey}) {\n      const {\n        getThumbPercent,\n        setThumbPercent,\n        decrementThumb,\n        incrementThumb,\n        step,\n        pageSize\n      } = state;\n      let {width, height} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        if ((deltaX > 0 && reverseX) || (deltaX < 0 && !reverseX) || deltaY > 0) {\n          decrementThumb(index, shiftKey ? pageSize : step);\n        } else {\n          incrementThumb(index, shiftKey ? pageSize : step);\n        }\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const {focusableProps} = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined)\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') {\n    thumbPosition = 1 - thumbPosition;\n  }\n\n  let interactions = !isDisabled ? mergeProps(\n    keyboardProps,\n    moveProps,\n    {\n      onMouseDown: (e: React.MouseEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown();\n      },\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown(e.pointerId);\n      },\n      onTouchStart: (e: React.TouchEvent) => {onDown(e.changedTouches[0].identifier);}\n    }\n  ) : {};\n\n  useFormReset(inputRef, value, (v) => {\n    state.setThumbValue(index, v);\n  });\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      name,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': isInvalid || validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'aria-describedby': [data['aria-describedby'], opts['aria-describedby']].filter(Boolean).join(' '),\n      'aria-details': [data['aria-details'], opts['aria-details']].filter(Boolean).join(' '),\n      onChange: (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: {\n      ...interactions,\n      style: {\n        position: 'absolute',\n        [isVertical ? 'top' : 'left']: `${thumbPosition * 100}%`,\n        transform: 'translate(-50%, -50%)',\n        touchAction: 'none'\n      }\n    },\n    labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled,\n    isFocused\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}