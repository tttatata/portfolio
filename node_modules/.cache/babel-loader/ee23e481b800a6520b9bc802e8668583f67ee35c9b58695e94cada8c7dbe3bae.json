{"ast":null,"code":"import { PressResponderContext } from \"./chunk-4XDBEIOV.mjs\";\nimport { PressEvent } from \"./chunk-7OGZUKMH.mjs\";\nimport { disableTextSelection, restoreTextSelection } from \"./chunk-CWMPADA3.mjs\";\nimport { getOwnerDocument, getOwnerWindow } from \"./chunk-FFBWCXWK.mjs\";\nimport \"./chunk-7D66DBGQ.mjs\";\n\n// src/index.ts\nimport { focusWithoutScrolling, isMac, isVirtualClick, isVirtualPointerEvent, mergeProps, openLink, useEffectEvent, useGlobalListeners, useSyncRef } from \"@react-aria/utils\";\nimport { useContext, useEffect, useMemo, useRef, useState } from \"react\";\nfunction usePressResponderContext(props) {\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {\n      register,\n      ...contextProps\n    } = context;\n    props = mergeProps(contextProps, props);\n    register();\n  }\n  useSyncRef(context, props.ref);\n  return props;\n}\nvar LINK_CLICKED = Symbol(\"linkClicked\");\nfunction usePress(props) {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    ref: _,\n    ...domProps\n  } = usePressResponderContext(props);\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n  let {\n    addGlobalListener,\n    removeAllGlobalListeners\n  } = useGlobalListeners();\n  let triggerPressStart = useEffectEvent((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return;\n    }\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent(\"pressstart\", pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) {\n      onPressChange(true);\n    }\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  let triggerPressEnd = useEffectEvent(function (originalEvent, pointerType) {\n    let wasPressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return;\n    }\n    state.ignoreClickAfterPress = true;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent(\"pressend\", pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) {\n      onPressChange(false);\n    }\n    setPressed(false);\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent(\"press\", pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n    }\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n  let triggerPressUp = useEffectEvent((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return;\n    }\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent(\"pressup\", pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n    return true;\n  });\n  let cancel = useEffectEvent(e => {\n    let state = ref.current;\n    if (state.isPressed) {\n      if (state.isOverTarget && state.target) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress && state.target) {\n        restoreTextSelection(state.target);\n      }\n    }\n  });\n  let cancelOnPointerExit = useEffectEvent(e => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps2 = {\n      onKeyDown(e) {\n        var _a;\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n          if (shouldPreventDefaultKeyboard(e.target, e.key)) {\n            e.preventDefault();\n          }\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n            addGlobalListener(getOwnerDocument(e.currentTarget), \"keyup\", onKeyUp, false);\n          }\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n          if (e.metaKey && isMac()) {\n            (_a = state.metaKeyEvents) == null ? void 0 : _a.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === \"Meta\") {\n          state.metaKeyEvents = /* @__PURE__ */new Map();\n        }\n      },\n      onKeyUp(e) {\n        if (state.target && isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) {\n          triggerPressUp(createEvent(state.target, e), \"keyboard\");\n        }\n      },\n      onClick(e) {\n        if (e && !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (e && e.button === 0 && !state.isTriggeringEvent && !openLink.isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || isVirtualClick(e.nativeEvent))) {\n            if (!isDisabled && !preventFocusOnPress) {\n              focusWithoutScrolling(e.currentTarget);\n            }\n            let stopPressStart = triggerPressStart(e, \"virtual\");\n            let stopPressUp = triggerPressUp(e, \"virtual\");\n            let stopPressEnd = triggerPressEnd(e, \"virtual\");\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n    let onKeyUp = e => {\n      var _a, _b;\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(e.target, e.key)) {\n          e.preventDefault();\n        }\n        let target = e.target;\n        let shouldStopPropagation = triggerPressEnd(createEvent(state.target, e), \"keyboard\", state.target.contains(target));\n        removeAllGlobalListeners();\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        if (e.key !== \"Enter\" && isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[LINK_CLICKED]) {\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n        state.isPressed = false;\n        (_a = state.metaKeyEvents) == null ? void 0 : _a.delete(e.key);\n      } else if (e.key === \"Meta\" && ((_b = state.metaKeyEvents) == null ? void 0 : _b.size)) {\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = null;\n        for (let event of events.values()) {\n          state.target && state.target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n        }\n      }\n    };\n    if (typeof PointerEvent !== \"undefined\") {\n      pressProps2.onPointerDown = e => {\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = \"virtual\";\n          return;\n        }\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n        state.pointerType = e.pointerType;\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!isDisabled && !preventFocusOnPress) {\n            focusWithoutScrolling(e.currentTarget);\n          }\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointermove\", onPointerMove, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointerup\", onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointercancel\", onPointerCancel, false);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseDown = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (e.button === 0) {\n          if (shouldPreventDefault(e.currentTarget)) {\n            e.preventDefault();\n          }\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onPointerUp = e => {\n        if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") {\n          return;\n        }\n        if (e.button === 0 && isOverTarget(e, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n      let onPointerMove = e => {\n        if (e.pointerId !== state.activePointerId || !state.target) {\n          return;\n        }\n        if (isOverTarget(e, state.target)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            triggerPressStart(createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n      let onPointerUp = e => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (isOverTarget(e, state.target)) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          } else if (state.isOverTarget) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          }\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) {\n            restoreTextSelection(state.target);\n          }\n        }\n      };\n      let onPointerCancel = e => {\n        cancel(e);\n      };\n      pressProps2.onDragStart = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        cancel(e);\n      };\n    } else {\n      pressProps2.onMouseDown = e => {\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? \"virtual\" : \"mouse\";\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        addGlobalListener(getOwnerDocument(e.currentTarget), \"mouseup\", onMouseUp, false);\n      };\n      pressProps2.onMouseEnter = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseLeave = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseUp = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\n          triggerPressUp(e, state.pointerType || \"mouse\");\n        }\n      };\n      let onMouseUp = e => {\n        if (e.button !== 0) {\n          return;\n        }\n        state.isPressed = false;\n        removeAllGlobalListeners();\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n        if (!state.target) {\n          return;\n        }\n        if (isOverTarget(e, state.target)) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType);\n        } else if (state.isOverTarget) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n        }\n        state.isOverTarget = false;\n      };\n      pressProps2.onTouchStart = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = \"touch\";\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        addGlobalListener(getOwnerWindow(e.currentTarget), \"scroll\", onScroll, true);\n      };\n      pressProps2.onTouchMove = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onTouchEnd = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget) {\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (!allowTextSelectionOnPress && state.target) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n      pressProps2.onTouchCancel = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(e);\n        }\n      };\n      let onScroll = e => {\n        if (state.isPressed && e.target.contains(state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n      pressProps2.onDragStart = e => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        cancel(e);\n      };\n    }\n    return pressProps2;\n  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners, allowTextSelectionOnPress, cancel, cancelOnPointerExit, triggerPressEnd, triggerPressStart, triggerPressUp]);\n  useEffect(() => {\n    return () => {\n      if (!allowTextSelectionOnPress && ref.current.target) {\n        restoreTextSelection(ref.current.target);\n      }\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps)\n  };\n}\nfunction isHTMLAnchorLink(target) {\n  return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction isValidKeyboardEvent(event, currentTarget) {\n  const {\n    key,\n    code\n  } = event;\n  const element = currentTarget;\n  const role = element.getAttribute(\"role\");\n  return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key) || element instanceof getOwnerWindow(element).HTMLTextAreaElement || element.isContentEditable) && !((role === \"link\" || !role && isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction getTouchFromEvent(event) {\n  const {\n    targetTouches\n  } = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\nfunction getTouchById(event, pointerId) {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\nfunction createEvent(target, e) {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\nfunction getPointClientRect(point) {\n  let offsetX = !!point.width ? point.width / 2 : point.radiusX || 0;\n  let offsetY = !!point.height ? point.height / 2 : point.radiusY || 0;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\nfunction areRectanglesOverlapping(a, b) {\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\nfunction isOverTarget(point, target) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\nfunction shouldPreventDefault(target) {\n  return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== \"submit\" && target.type !== \"reset\";\n  }\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n  return true;\n}\nvar nonTextInputTypes = /* @__PURE__ */new Set([\"checkbox\", \"radio\", \"range\", \"color\", \"file\", \"image\", \"button\", \"submit\", \"reset\"]);\nfunction isValidInputKey(target, key) {\n  return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : nonTextInputTypes.has(target.type);\n}\nexport { usePress };","map":{"version":3,"names":["PressResponderContext","PressEvent","disableTextSelection","restoreTextSelection","getOwnerDocument","getOwnerWindow","focusWithoutScrolling","isMac","isVirtualClick","isVirtualPointerEvent","mergeProps","openLink","useEffectEvent","useGlobalListeners","useSyncRef","useContext","useEffect","useMemo","useRef","useState","usePressResponderContext","props","context","register","contextProps","ref","LINK_CLICKED","Symbol","usePress","onPress","onPressChange","onPressStart","onPressEnd","onPressUp","isDisabled","isPressed","isPressedProp","preventFocusOnPress","shouldCancelOnPointerExit","allowTextSelectionOnPress","_","domProps","setPressed","ignoreEmulatedMouseEvents","ignoreClickAfterPress","didFirePressStart","isTriggeringEvent","activePointerId","target","isOverTarget","pointerType","addGlobalListener","removeAllGlobalListeners","triggerPressStart","originalEvent","state","current","shouldStopPropagation","event","triggerPressEnd","wasPressed","arguments","length","undefined","triggerPressUp","cancel","e","createEvent","cancelOnPointerExit","pressProps","pressProps2","onKeyDown","_a","isValidKeyboardEvent","nativeEvent","currentTarget","contains","shouldPreventDefaultKeyboard","key","preventDefault","repeat","onKeyUp","stopPropagation","metaKey","metaKeyEvents","set","Map","onClick","button","isOpening","stopPressStart","stopPressUp","stopPressEnd","_b","isHTMLAnchorLink","delete","size","events","values","dispatchEvent","KeyboardEvent","PointerEvent","onPointerDown","shouldPreventDefault","pointerId","onPointerMove","onPointerUp","onPointerCancel","onMouseDown","onDragStart","onMouseUp","onMouseEnter","onMouseLeave","onTouchStart","touch","getTouchFromEvent","identifier","onScroll","onTouchMove","getTouchById","onTouchEnd","onTouchCancel","shiftKey","ctrlKey","altKey","tagName","hasAttribute","code","element","role","getAttribute","HTMLInputElement","isValidInputKey","HTMLTextAreaElement","isContentEditable","targetTouches","changedTouches","i","getPointClientRect","point","offsetX","width","radiusX","offsetY","height","radiusY","top","clientY","right","clientX","bottom","left","areRectanglesOverlapping","a","b","rect","getBoundingClientRect","pointRect","HTMLElement","HTMLButtonElement","type","nonTextInputTypes","Set","has"],"sources":["D:/TranThaiThanh_TranHuuMinhThuong_BaoCao_Nhom17/frontend/node_modules/@nextui-org/use-aria-press/dist/index.mjs"],"sourcesContent":["import {\n  PressResponderContext\n} from \"./chunk-4XDBEIOV.mjs\";\nimport {\n  PressEvent\n} from \"./chunk-7OGZUKMH.mjs\";\nimport {\n  disableTextSelection,\n  restoreTextSelection\n} from \"./chunk-CWMPADA3.mjs\";\nimport {\n  getOwnerDocument,\n  getOwnerWindow\n} from \"./chunk-FFBWCXWK.mjs\";\nimport \"./chunk-7D66DBGQ.mjs\";\n\n// src/index.ts\nimport {\n  focusWithoutScrolling,\n  isMac,\n  isVirtualClick,\n  isVirtualPointerEvent,\n  mergeProps,\n  openLink,\n  useEffectEvent,\n  useGlobalListeners,\n  useSyncRef\n} from \"@react-aria/utils\";\nimport { useContext, useEffect, useMemo, useRef, useState } from \"react\";\nfunction usePressResponderContext(props) {\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let { register, ...contextProps } = context;\n    props = mergeProps(contextProps, props);\n    register();\n  }\n  useSyncRef(context, props.ref);\n  return props;\n}\nvar LINK_CLICKED = Symbol(\"linkClicked\");\nfunction usePress(props) {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    ref: _,\n    ...domProps\n  } = usePressResponderContext(props);\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n  let { addGlobalListener, removeAllGlobalListeners } = useGlobalListeners();\n  let triggerPressStart = useEffectEvent((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return;\n    }\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent(\"pressstart\", pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) {\n      onPressChange(true);\n    }\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  let triggerPressEnd = useEffectEvent(\n    (originalEvent, pointerType, wasPressed = true) => {\n      let state = ref.current;\n      if (!state.didFirePressStart) {\n        return;\n      }\n      state.ignoreClickAfterPress = true;\n      state.didFirePressStart = false;\n      state.isTriggeringEvent = true;\n      let shouldStopPropagation = true;\n      if (onPressEnd) {\n        let event = new PressEvent(\"pressend\", pointerType, originalEvent);\n        onPressEnd(event);\n        shouldStopPropagation = event.shouldStopPropagation;\n      }\n      if (onPressChange) {\n        onPressChange(false);\n      }\n      setPressed(false);\n      if (onPress && wasPressed && !isDisabled) {\n        let event = new PressEvent(\"press\", pointerType, originalEvent);\n        onPress(event);\n        shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n      }\n      state.isTriggeringEvent = false;\n      return shouldStopPropagation;\n    }\n  );\n  let triggerPressUp = useEffectEvent((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return;\n    }\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent(\"pressup\", pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n    return true;\n  });\n  let cancel = useEffectEvent((e) => {\n    let state = ref.current;\n    if (state.isPressed) {\n      if (state.isOverTarget && state.target) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress && state.target) {\n        restoreTextSelection(state.target);\n      }\n    }\n  });\n  let cancelOnPointerExit = useEffectEvent((e) => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps2 = {\n      onKeyDown(e) {\n        var _a;\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n          if (shouldPreventDefaultKeyboard(e.target, e.key)) {\n            e.preventDefault();\n          }\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n            addGlobalListener(getOwnerDocument(e.currentTarget), \"keyup\", onKeyUp, false);\n          }\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n          if (e.metaKey && isMac()) {\n            (_a = state.metaKeyEvents) == null ? void 0 : _a.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === \"Meta\") {\n          state.metaKeyEvents = /* @__PURE__ */ new Map();\n        }\n      },\n      onKeyUp(e) {\n        if (state.target && isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) {\n          triggerPressUp(createEvent(state.target, e), \"keyboard\");\n        }\n      },\n      onClick(e) {\n        if (e && !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (e && e.button === 0 && !state.isTriggeringEvent && !openLink.isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || isVirtualClick(e.nativeEvent))) {\n            if (!isDisabled && !preventFocusOnPress) {\n              focusWithoutScrolling(e.currentTarget);\n            }\n            let stopPressStart = triggerPressStart(e, \"virtual\");\n            let stopPressUp = triggerPressUp(e, \"virtual\");\n            let stopPressEnd = triggerPressEnd(e, \"virtual\");\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n    let onKeyUp = (e) => {\n      var _a, _b;\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(e.target, e.key)) {\n          e.preventDefault();\n        }\n        let target = e.target;\n        let shouldStopPropagation = triggerPressEnd(\n          createEvent(state.target, e),\n          \"keyboard\",\n          state.target.contains(target)\n        );\n        removeAllGlobalListeners();\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        if (e.key !== \"Enter\" && isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[LINK_CLICKED]) {\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n        state.isPressed = false;\n        (_a = state.metaKeyEvents) == null ? void 0 : _a.delete(e.key);\n      } else if (e.key === \"Meta\" && ((_b = state.metaKeyEvents) == null ? void 0 : _b.size)) {\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = null;\n        for (let event of events.values()) {\n          state.target && state.target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n        }\n      }\n    };\n    if (typeof PointerEvent !== \"undefined\") {\n      pressProps2.onPointerDown = (e) => {\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = \"virtual\";\n          return;\n        }\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n        state.pointerType = e.pointerType;\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!isDisabled && !preventFocusOnPress) {\n            focusWithoutScrolling(e.currentTarget);\n          }\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointermove\", onPointerMove, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), \"pointerup\", onPointerUp, false);\n          addGlobalListener(\n            getOwnerDocument(e.currentTarget),\n            \"pointercancel\",\n            onPointerCancel,\n            false\n          );\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseDown = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (e.button === 0) {\n          if (shouldPreventDefault(e.currentTarget)) {\n            e.preventDefault();\n          }\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onPointerUp = (e) => {\n        if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") {\n          return;\n        }\n        if (e.button === 0 && isOverTarget(e, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n      let onPointerMove = (e) => {\n        if (e.pointerId !== state.activePointerId || !state.target) {\n          return;\n        }\n        if (isOverTarget(e, state.target)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            triggerPressStart(createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n      let onPointerUp = (e) => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (isOverTarget(e, state.target)) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          } else if (state.isOverTarget) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          }\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) {\n            restoreTextSelection(state.target);\n          }\n        }\n      };\n      let onPointerCancel = (e) => {\n        cancel(e);\n      };\n      pressProps2.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        cancel(e);\n      };\n    } else {\n      pressProps2.onMouseDown = (e) => {\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? \"virtual\" : \"mouse\";\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        addGlobalListener(getOwnerDocument(e.currentTarget), \"mouseup\", onMouseUp, false);\n      };\n      pressProps2.onMouseEnter = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseLeave = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onMouseUp = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\n          triggerPressUp(e, state.pointerType || \"mouse\");\n        }\n      };\n      let onMouseUp = (e) => {\n        if (e.button !== 0) {\n          return;\n        }\n        state.isPressed = false;\n        removeAllGlobalListeners();\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n        if (!state.target) {\n          return;\n        }\n        if (isOverTarget(e, state.target)) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType);\n        } else if (state.isOverTarget) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n        }\n        state.isOverTarget = false;\n      };\n      pressProps2.onTouchStart = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = \"touch\";\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        addGlobalListener(getOwnerWindow(e.currentTarget), \"scroll\", onScroll, true);\n      };\n      pressProps2.onTouchMove = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n      pressProps2.onTouchEnd = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget) {\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        }\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (!allowTextSelectionOnPress && state.target) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n      pressProps2.onTouchCancel = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(e);\n        }\n      };\n      let onScroll = (e) => {\n        if (state.isPressed && e.target.contains(state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n      pressProps2.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target)) {\n          return;\n        }\n        cancel(e);\n      };\n    }\n    return pressProps2;\n  }, [\n    addGlobalListener,\n    isDisabled,\n    preventFocusOnPress,\n    removeAllGlobalListeners,\n    allowTextSelectionOnPress,\n    cancel,\n    cancelOnPointerExit,\n    triggerPressEnd,\n    triggerPressStart,\n    triggerPressUp\n  ]);\n  useEffect(() => {\n    return () => {\n      if (!allowTextSelectionOnPress && ref.current.target) {\n        restoreTextSelection(ref.current.target);\n      }\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps)\n  };\n}\nfunction isHTMLAnchorLink(target) {\n  return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction isValidKeyboardEvent(event, currentTarget) {\n  const { key, code } = event;\n  const element = currentTarget;\n  const role = element.getAttribute(\"role\");\n  return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key) || element instanceof getOwnerWindow(element).HTMLTextAreaElement || element.isContentEditable) && !((role === \"link\" || !role && isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction getTouchFromEvent(event) {\n  const { targetTouches } = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\nfunction getTouchById(event, pointerId) {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\nfunction createEvent(target, e) {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\nfunction getPointClientRect(point) {\n  let offsetX = !!point.width ? point.width / 2 : point.radiusX || 0;\n  let offsetY = !!point.height ? point.height / 2 : point.radiusY || 0;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\nfunction areRectanglesOverlapping(a, b) {\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\nfunction isOverTarget(point, target) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\nfunction shouldPreventDefault(target) {\n  return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== \"submit\" && target.type !== \"reset\";\n  }\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n  return true;\n}\nvar nonTextInputTypes = /* @__PURE__ */ new Set([\n  \"checkbox\",\n  \"radio\",\n  \"range\",\n  \"color\",\n  \"file\",\n  \"image\",\n  \"button\",\n  \"submit\",\n  \"reset\"\n]);\nfunction isValidInputKey(target, key) {\n  return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : nonTextInputTypes.has(target.type);\n}\nexport {\n  usePress\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}